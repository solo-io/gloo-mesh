// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v1alpha1

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// MulticlusterClientset for the networking.smh.solo.io/v1alpha1 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the networking.smh.solo.io/v1alpha1 APIs
type Clientset interface {
	// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
	TrafficPolicies() TrafficPolicyClient
	// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
	AccessControlPolicies() AccessControlPolicyClient
	// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
	VirtualMeshes() VirtualMeshClient
	// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
	FailoverServices() FailoverServiceClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
func (c *clientSet) TrafficPolicies() TrafficPolicyClient {
	return NewTrafficPolicyClient(c.client)
}

// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
func (c *clientSet) AccessControlPolicies() AccessControlPolicyClient {
	return NewAccessControlPolicyClient(c.client)
}

// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
func (c *clientSet) VirtualMeshes() VirtualMeshClient {
	return NewVirtualMeshClient(c.client)
}

// clienset for the networking.smh.solo.io/v1alpha1/v1alpha1 APIs
func (c *clientSet) FailoverServices() FailoverServiceClient {
	return NewFailoverServiceClient(c.client)
}

// Reader knows how to read and list TrafficPolicys.
type TrafficPolicyReader interface {
	// Get retrieves a TrafficPolicy for the given object key
	GetTrafficPolicy(ctx context.Context, key client.ObjectKey) (*TrafficPolicy, error)

	// List retrieves list of TrafficPolicys for a given namespace and list options.
	ListTrafficPolicy(ctx context.Context, opts ...client.ListOption) (*TrafficPolicyList, error)
}

// TrafficPolicyTransitionFunction instructs the TrafficPolicyWriter how to transition between an existing
// TrafficPolicy object and a desired on an Upsert
type TrafficPolicyTransitionFunction func(existing, desired *TrafficPolicy) error

// Writer knows how to create, delete, and update TrafficPolicys.
type TrafficPolicyWriter interface {
	// Create saves the TrafficPolicy object.
	CreateTrafficPolicy(ctx context.Context, obj *TrafficPolicy, opts ...client.CreateOption) error

	// Delete deletes the TrafficPolicy object.
	DeleteTrafficPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given TrafficPolicy object.
	UpdateTrafficPolicy(ctx context.Context, obj *TrafficPolicy, opts ...client.UpdateOption) error

	// Patch patches the given TrafficPolicy object.
	PatchTrafficPolicy(ctx context.Context, obj *TrafficPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all TrafficPolicy objects matching the given options.
	DeleteAllOfTrafficPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the TrafficPolicy object.
	UpsertTrafficPolicy(ctx context.Context, obj *TrafficPolicy, transitionFuncs ...TrafficPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a TrafficPolicy object.
type TrafficPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given TrafficPolicy object.
	UpdateTrafficPolicyStatus(ctx context.Context, obj *TrafficPolicy, opts ...client.UpdateOption) error

	// Patch patches the given TrafficPolicy object's subresource.
	PatchTrafficPolicyStatus(ctx context.Context, obj *TrafficPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on TrafficPolicys.
type TrafficPolicyClient interface {
	TrafficPolicyReader
	TrafficPolicyWriter
	TrafficPolicyStatusWriter
}

type trafficPolicyClient struct {
	client client.Client
}

func NewTrafficPolicyClient(client client.Client) *trafficPolicyClient {
	return &trafficPolicyClient{client: client}
}

func (c *trafficPolicyClient) GetTrafficPolicy(ctx context.Context, key client.ObjectKey) (*TrafficPolicy, error) {
	obj := &TrafficPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *trafficPolicyClient) ListTrafficPolicy(ctx context.Context, opts ...client.ListOption) (*TrafficPolicyList, error) {
	list := &TrafficPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *trafficPolicyClient) CreateTrafficPolicy(ctx context.Context, obj *TrafficPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *trafficPolicyClient) DeleteTrafficPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &TrafficPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *trafficPolicyClient) UpdateTrafficPolicy(ctx context.Context, obj *TrafficPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *trafficPolicyClient) PatchTrafficPolicy(ctx context.Context, obj *TrafficPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *trafficPolicyClient) DeleteAllOfTrafficPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &TrafficPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *trafficPolicyClient) UpsertTrafficPolicy(ctx context.Context, obj *TrafficPolicy, transitionFuncs ...TrafficPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*TrafficPolicy), desired.(*TrafficPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *trafficPolicyClient) UpdateTrafficPolicyStatus(ctx context.Context, obj *TrafficPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *trafficPolicyClient) PatchTrafficPolicyStatus(ctx context.Context, obj *TrafficPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides TrafficPolicyClients for multiple clusters.
type MulticlusterTrafficPolicyClient interface {
	// Cluster returns a TrafficPolicyClient for the given cluster
	Cluster(cluster string) (TrafficPolicyClient, error)
}

type multiclusterTrafficPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterTrafficPolicyClient(client multicluster.Client) MulticlusterTrafficPolicyClient {
	return &multiclusterTrafficPolicyClient{client: client}
}

func (m *multiclusterTrafficPolicyClient) Cluster(cluster string) (TrafficPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewTrafficPolicyClient(client), nil
}

// Reader knows how to read and list AccessControlPolicys.
type AccessControlPolicyReader interface {
	// Get retrieves a AccessControlPolicy for the given object key
	GetAccessControlPolicy(ctx context.Context, key client.ObjectKey) (*AccessControlPolicy, error)

	// List retrieves list of AccessControlPolicys for a given namespace and list options.
	ListAccessControlPolicy(ctx context.Context, opts ...client.ListOption) (*AccessControlPolicyList, error)
}

// AccessControlPolicyTransitionFunction instructs the AccessControlPolicyWriter how to transition between an existing
// AccessControlPolicy object and a desired on an Upsert
type AccessControlPolicyTransitionFunction func(existing, desired *AccessControlPolicy) error

// Writer knows how to create, delete, and update AccessControlPolicys.
type AccessControlPolicyWriter interface {
	// Create saves the AccessControlPolicy object.
	CreateAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, opts ...client.CreateOption) error

	// Delete deletes the AccessControlPolicy object.
	DeleteAccessControlPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given AccessControlPolicy object.
	UpdateAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, opts ...client.UpdateOption) error

	// Patch patches the given AccessControlPolicy object.
	PatchAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all AccessControlPolicy objects matching the given options.
	DeleteAllOfAccessControlPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the AccessControlPolicy object.
	UpsertAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, transitionFuncs ...AccessControlPolicyTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a AccessControlPolicy object.
type AccessControlPolicyStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given AccessControlPolicy object.
	UpdateAccessControlPolicyStatus(ctx context.Context, obj *AccessControlPolicy, opts ...client.UpdateOption) error

	// Patch patches the given AccessControlPolicy object's subresource.
	PatchAccessControlPolicyStatus(ctx context.Context, obj *AccessControlPolicy, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on AccessControlPolicys.
type AccessControlPolicyClient interface {
	AccessControlPolicyReader
	AccessControlPolicyWriter
	AccessControlPolicyStatusWriter
}

type accessControlPolicyClient struct {
	client client.Client
}

func NewAccessControlPolicyClient(client client.Client) *accessControlPolicyClient {
	return &accessControlPolicyClient{client: client}
}

func (c *accessControlPolicyClient) GetAccessControlPolicy(ctx context.Context, key client.ObjectKey) (*AccessControlPolicy, error) {
	obj := &AccessControlPolicy{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *accessControlPolicyClient) ListAccessControlPolicy(ctx context.Context, opts ...client.ListOption) (*AccessControlPolicyList, error) {
	list := &AccessControlPolicyList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *accessControlPolicyClient) CreateAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *accessControlPolicyClient) DeleteAccessControlPolicy(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &AccessControlPolicy{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *accessControlPolicyClient) UpdateAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *accessControlPolicyClient) PatchAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *accessControlPolicyClient) DeleteAllOfAccessControlPolicy(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &AccessControlPolicy{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *accessControlPolicyClient) UpsertAccessControlPolicy(ctx context.Context, obj *AccessControlPolicy, transitionFuncs ...AccessControlPolicyTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*AccessControlPolicy), desired.(*AccessControlPolicy)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *accessControlPolicyClient) UpdateAccessControlPolicyStatus(ctx context.Context, obj *AccessControlPolicy, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *accessControlPolicyClient) PatchAccessControlPolicyStatus(ctx context.Context, obj *AccessControlPolicy, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides AccessControlPolicyClients for multiple clusters.
type MulticlusterAccessControlPolicyClient interface {
	// Cluster returns a AccessControlPolicyClient for the given cluster
	Cluster(cluster string) (AccessControlPolicyClient, error)
}

type multiclusterAccessControlPolicyClient struct {
	client multicluster.Client
}

func NewMulticlusterAccessControlPolicyClient(client multicluster.Client) MulticlusterAccessControlPolicyClient {
	return &multiclusterAccessControlPolicyClient{client: client}
}

func (m *multiclusterAccessControlPolicyClient) Cluster(cluster string) (AccessControlPolicyClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewAccessControlPolicyClient(client), nil
}

// Reader knows how to read and list VirtualMeshs.
type VirtualMeshReader interface {
	// Get retrieves a VirtualMesh for the given object key
	GetVirtualMesh(ctx context.Context, key client.ObjectKey) (*VirtualMesh, error)

	// List retrieves list of VirtualMeshs for a given namespace and list options.
	ListVirtualMesh(ctx context.Context, opts ...client.ListOption) (*VirtualMeshList, error)
}

// VirtualMeshTransitionFunction instructs the VirtualMeshWriter how to transition between an existing
// VirtualMesh object and a desired on an Upsert
type VirtualMeshTransitionFunction func(existing, desired *VirtualMesh) error

// Writer knows how to create, delete, and update VirtualMeshs.
type VirtualMeshWriter interface {
	// Create saves the VirtualMesh object.
	CreateVirtualMesh(ctx context.Context, obj *VirtualMesh, opts ...client.CreateOption) error

	// Delete deletes the VirtualMesh object.
	DeleteVirtualMesh(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given VirtualMesh object.
	UpdateVirtualMesh(ctx context.Context, obj *VirtualMesh, opts ...client.UpdateOption) error

	// Patch patches the given VirtualMesh object.
	PatchVirtualMesh(ctx context.Context, obj *VirtualMesh, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all VirtualMesh objects matching the given options.
	DeleteAllOfVirtualMesh(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the VirtualMesh object.
	UpsertVirtualMesh(ctx context.Context, obj *VirtualMesh, transitionFuncs ...VirtualMeshTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a VirtualMesh object.
type VirtualMeshStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given VirtualMesh object.
	UpdateVirtualMeshStatus(ctx context.Context, obj *VirtualMesh, opts ...client.UpdateOption) error

	// Patch patches the given VirtualMesh object's subresource.
	PatchVirtualMeshStatus(ctx context.Context, obj *VirtualMesh, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on VirtualMeshs.
type VirtualMeshClient interface {
	VirtualMeshReader
	VirtualMeshWriter
	VirtualMeshStatusWriter
}

type virtualMeshClient struct {
	client client.Client
}

func NewVirtualMeshClient(client client.Client) *virtualMeshClient {
	return &virtualMeshClient{client: client}
}

func (c *virtualMeshClient) GetVirtualMesh(ctx context.Context, key client.ObjectKey) (*VirtualMesh, error) {
	obj := &VirtualMesh{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *virtualMeshClient) ListVirtualMesh(ctx context.Context, opts ...client.ListOption) (*VirtualMeshList, error) {
	list := &VirtualMeshList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *virtualMeshClient) CreateVirtualMesh(ctx context.Context, obj *VirtualMesh, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *virtualMeshClient) DeleteVirtualMesh(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &VirtualMesh{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *virtualMeshClient) UpdateVirtualMesh(ctx context.Context, obj *VirtualMesh, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *virtualMeshClient) PatchVirtualMesh(ctx context.Context, obj *VirtualMesh, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *virtualMeshClient) DeleteAllOfVirtualMesh(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &VirtualMesh{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *virtualMeshClient) UpsertVirtualMesh(ctx context.Context, obj *VirtualMesh, transitionFuncs ...VirtualMeshTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*VirtualMesh), desired.(*VirtualMesh)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *virtualMeshClient) UpdateVirtualMeshStatus(ctx context.Context, obj *VirtualMesh, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *virtualMeshClient) PatchVirtualMeshStatus(ctx context.Context, obj *VirtualMesh, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides VirtualMeshClients for multiple clusters.
type MulticlusterVirtualMeshClient interface {
	// Cluster returns a VirtualMeshClient for the given cluster
	Cluster(cluster string) (VirtualMeshClient, error)
}

type multiclusterVirtualMeshClient struct {
	client multicluster.Client
}

func NewMulticlusterVirtualMeshClient(client multicluster.Client) MulticlusterVirtualMeshClient {
	return &multiclusterVirtualMeshClient{client: client}
}

func (m *multiclusterVirtualMeshClient) Cluster(cluster string) (VirtualMeshClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewVirtualMeshClient(client), nil
}

// Reader knows how to read and list FailoverServices.
type FailoverServiceReader interface {
	// Get retrieves a FailoverService for the given object key
	GetFailoverService(ctx context.Context, key client.ObjectKey) (*FailoverService, error)

	// List retrieves list of FailoverServices for a given namespace and list options.
	ListFailoverService(ctx context.Context, opts ...client.ListOption) (*FailoverServiceList, error)
}

// FailoverServiceTransitionFunction instructs the FailoverServiceWriter how to transition between an existing
// FailoverService object and a desired on an Upsert
type FailoverServiceTransitionFunction func(existing, desired *FailoverService) error

// Writer knows how to create, delete, and update FailoverServices.
type FailoverServiceWriter interface {
	// Create saves the FailoverService object.
	CreateFailoverService(ctx context.Context, obj *FailoverService, opts ...client.CreateOption) error

	// Delete deletes the FailoverService object.
	DeleteFailoverService(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given FailoverService object.
	UpdateFailoverService(ctx context.Context, obj *FailoverService, opts ...client.UpdateOption) error

	// Patch patches the given FailoverService object.
	PatchFailoverService(ctx context.Context, obj *FailoverService, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all FailoverService objects matching the given options.
	DeleteAllOfFailoverService(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the FailoverService object.
	UpsertFailoverService(ctx context.Context, obj *FailoverService, transitionFuncs ...FailoverServiceTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a FailoverService object.
type FailoverServiceStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given FailoverService object.
	UpdateFailoverServiceStatus(ctx context.Context, obj *FailoverService, opts ...client.UpdateOption) error

	// Patch patches the given FailoverService object's subresource.
	PatchFailoverServiceStatus(ctx context.Context, obj *FailoverService, patch client.Patch, opts ...client.PatchOption) error
}

// Client knows how to perform CRUD operations on FailoverServices.
type FailoverServiceClient interface {
	FailoverServiceReader
	FailoverServiceWriter
	FailoverServiceStatusWriter
}

type failoverServiceClient struct {
	client client.Client
}

func NewFailoverServiceClient(client client.Client) *failoverServiceClient {
	return &failoverServiceClient{client: client}
}

func (c *failoverServiceClient) GetFailoverService(ctx context.Context, key client.ObjectKey) (*FailoverService, error) {
	obj := &FailoverService{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *failoverServiceClient) ListFailoverService(ctx context.Context, opts ...client.ListOption) (*FailoverServiceList, error) {
	list := &FailoverServiceList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *failoverServiceClient) CreateFailoverService(ctx context.Context, obj *FailoverService, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *failoverServiceClient) DeleteFailoverService(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &FailoverService{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *failoverServiceClient) UpdateFailoverService(ctx context.Context, obj *FailoverService, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *failoverServiceClient) PatchFailoverService(ctx context.Context, obj *FailoverService, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *failoverServiceClient) DeleteAllOfFailoverService(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &FailoverService{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *failoverServiceClient) UpsertFailoverService(ctx context.Context, obj *FailoverService, transitionFuncs ...FailoverServiceTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*FailoverService), desired.(*FailoverService)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *failoverServiceClient) UpdateFailoverServiceStatus(ctx context.Context, obj *FailoverService, opts ...client.UpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *failoverServiceClient) PatchFailoverServiceStatus(ctx context.Context, obj *FailoverService, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides FailoverServiceClients for multiple clusters.
type MulticlusterFailoverServiceClient interface {
	// Cluster returns a FailoverServiceClient for the given cluster
	Cluster(cluster string) (FailoverServiceClient, error)
}

type multiclusterFailoverServiceClient struct {
	client multicluster.Client
}

func NewMulticlusterFailoverServiceClient(client multicluster.Client) MulticlusterFailoverServiceClient {
	return &multiclusterFailoverServiceClient{client: client}
}

func (m *multiclusterFailoverServiceClient) Cluster(cluster string) (FailoverServiceClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewFailoverServiceClient(client), nil
}
