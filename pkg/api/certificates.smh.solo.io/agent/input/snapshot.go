// Code generated by skv2. DO NOT EDIT.

// The Input Snapshot contains the set of all:
// * IssuedCertificates
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the SnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/hashicorp/go-multierror"
	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"

	certificates_smh_solo_io_v1alpha2 "github.com/solo-io/service-mesh-hub/pkg/api/certificates.smh.solo.io/v1alpha2"
	certificates_smh_solo_io_v1alpha2_sets "github.com/solo-io/service-mesh-hub/pkg/api/certificates.smh.solo.io/v1alpha2/sets"
)

// the snapshot of input resources consumed by translation
type Snapshot interface {

	// return the set of input IssuedCertificates
	IssuedCertificates() certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet
	// update the status of all input objects which support
	// the Status subresource
	SyncStatuses(ctx context.Context, c client.Client) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

type snapshot struct {
	name string

	issuedCertificates certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet
}

func NewSnapshot(
	name string,

	issuedCertificates certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet,

) Snapshot {
	return &snapshot{
		name: name,

		issuedCertificates: issuedCertificates,
	}
}

func (s snapshot) IssuedCertificates() certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return s.issuedCertificates
}
func (s snapshot) SyncStatuses(ctx context.Context, c client.Client) error {

	for _, obj := range s.IssuedCertificates().List() {
		if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
			return err
		}
	}
	return nil
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["issuedCertificates"] = s.issuedCertificates.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
// Two types of builders are available:
// a builder for snapshots of resources across multiple clusters
// a builder for snapshots of resources within a single cluster
type Builder interface {
	BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error)
}

// Options for building a snapshot
type BuildOptions struct {

	// List options for composing a snapshot from IssuedCertificates
	IssuedCertificates []client.ListOption
}

// build a snapshot from resources across multiple clusters
type multiClusterBuilder struct {
	clusters multicluster.ClusterSet

	issuedCertificates certificates_smh_solo_io_v1alpha2.MulticlusterIssuedCertificateClient
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterBuilder(
	clusters multicluster.ClusterSet,
	client multicluster.Client,
) Builder {
	return &multiClusterBuilder{
		clusters: clusters,

		issuedCertificates: certificates_smh_solo_io_v1alpha2.NewMulticlusterIssuedCertificateClient(client),
	}
}

func (b *multiClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	issuedCertificates := certificates_smh_solo_io_v1alpha2_sets.NewIssuedCertificateSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertIssuedCertificatesFromCluster(ctx, cluster, issuedCertificates, opts.IssuedCertificates...); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewSnapshot(
		name,

		issuedCertificates,
	)

	return outputSnap, errs
}

func (b *multiClusterBuilder) insertIssuedCertificatesFromCluster(ctx context.Context, cluster string, issuedCertificates certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet, opts ...client.ListOption) error {
	issuedCertificateClient, err := b.issuedCertificates.Cluster(cluster)
	if err != nil {
		return err
	}

	issuedCertificateList, err := issuedCertificateClient.ListIssuedCertificate(ctx, opts...)
	if err != nil {
		return err
	}

	for _, item := range issuedCertificateList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		issuedCertificates.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterBuilder struct {
	issuedCertificates certificates_smh_solo_io_v1alpha2.IssuedCertificateClient
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewSingleClusterBuilder(
	client client.Client,
) Builder {
	return &singleClusterBuilder{

		issuedCertificates: certificates_smh_solo_io_v1alpha2.NewIssuedCertificateClient(client),
	}
}

func (b *singleClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	issuedCertificates := certificates_smh_solo_io_v1alpha2_sets.NewIssuedCertificateSet()

	var errs error

	if err := b.insertIssuedCertificates(ctx, issuedCertificates, opts.IssuedCertificates...); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewSnapshot(
		name,

		issuedCertificates,
	)

	return outputSnap, errs
}

func (b *singleClusterBuilder) insertIssuedCertificates(ctx context.Context, issuedCertificates certificates_smh_solo_io_v1alpha2_sets.IssuedCertificateSet, opts ...client.ListOption) error {
	issuedCertificateList, err := b.issuedCertificates.ListIssuedCertificate(ctx, opts...)
	if err != nil {
		return err
	}

	for _, item := range issuedCertificateList.Items {
		item := item // pike
		issuedCertificates.Insert(&item)
	}

	return nil
}
