// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rbac.proto

package v1alpha1 // import "github.com/solo-io/supergloo/pkg/api/external/istio/rbac/v1alpha1"

/*
Istio RBAC (Role Based Access Control) defines ServiceRole and ServiceRoleBinding
objects.

A ServiceRole specification includes a list of rules (permissions). Each rule has
the following standard fields:

  * services: a list of services.
  * methods: HTTP methods. In the case of gRPC, this field is ignored because the value is always "POST".
  * paths: HTTP paths or gRPC methods. Note that gRPC methods should be
    presented in the form of "/packageName.serviceName/methodName" and are case sensitive.

In addition to the standard fields, operators can also use custom keys in the `constraints` field,
the supported keys are listed in the "constraints and properties" page.

Below is an example of ServiceRole object "product-viewer", which has "read" ("GET" and "HEAD")
access to "products.svc.cluster.local" service at versions "v1" and "v2". "path" is not specified,
so it applies to any path in the service.

```yaml
apiVersion: "rbac.istio.io/v1alpha1"
kind: ServiceRole
metadata:
  name: products-viewer
  namespace: default
spec:
  rules:
  - services: ["products.svc.cluster.local"]
    methods: ["GET", "HEAD"]
    constraints:
    - key: "destination.labels[version]"
      value: ["v1", "v2"]
```

A ServiceRoleBinding specification includes two parts:

 * The `roleRef` field that refers to a ServiceRole object in the same namespace.
 * A list of `subjects` that are assigned the roles.

In addition to a simple `user` field, operators can also use custom keys in the `properties` field,
the supported keys are listed in the "constraints and properties" page.

Below is an example of ServiceRoleBinding object "test-binding-products", which binds two subjects
to ServiceRole "product-viewer":

  * User "alice@yahoo.com"
  * Services in "abc" namespace.

```yaml
apiVersion: "rbac.istio.io/v1alpha1"
kind: ServiceRoleBinding
metadata:
  name: test-binding-products
  namespace: default
spec:
  subjects:
  - user: alice@yahoo.com
  - properties:
      source.namespace: "abc"
  roleRef:
    kind: ServiceRole
    name: "products-viewer"
```
*/

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"

import bytes "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// $hide_from_docs
// RBAC ServiceRoleBinding enforcement mode, used to verify new ServiceRoleBinding
// configs work as expected before rolling to production. RBAC engine only logs results
// from configs that are in permissive mode, and discards result before returning
// to the user.
type EnforcementMode int32

const (
	// Policy in ENFORCED mode has impact on user experience.
	// Policy is in ENFORCED mode by default.
	EnforcementMode_ENFORCED EnforcementMode = 0
	// Policy in PERMISSIVE mode isn't enforced and has no impact on users.
	// RBAC engine run policies in PERMISSIVE mode and logs stats.
	EnforcementMode_PERMISSIVE EnforcementMode = 1
)

var EnforcementMode_name = map[int32]string{
	0: "ENFORCED",
	1: "PERMISSIVE",
}
var EnforcementMode_value = map[string]int32{
	"ENFORCED":   0,
	"PERMISSIVE": 1,
}

func (x EnforcementMode) String() string {
	return proto.EnumName(EnforcementMode_name, int32(x))
}
func (EnforcementMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{0}
}

type RbacConfig_Mode int32

const (
	// Disable Istio RBAC completely, any other config in RbacConfig will be ignored and Istio RBAC policies
	// will not be enforced.
	RbacConfig_OFF RbacConfig_Mode = 0
	// Enable Istio RBAC for all services and namespaces.
	RbacConfig_ON RbacConfig_Mode = 1
	// Enable Istio RBAC only for services and namespaces specified in the inclusion field. Any other
	// services and namespaces not in the inclusion field will not be enforced by Istio RBAC policies.
	RbacConfig_ON_WITH_INCLUSION RbacConfig_Mode = 2
	// Enable Istio RBAC for all services and namespaces except those specified in the exclusion field. Any other
	// services and namespaces not in the exclusion field will be enforced by Istio RBAC policies.
	RbacConfig_ON_WITH_EXCLUSION RbacConfig_Mode = 3
)

var RbacConfig_Mode_name = map[int32]string{
	0: "OFF",
	1: "ON",
	2: "ON_WITH_INCLUSION",
	3: "ON_WITH_EXCLUSION",
}
var RbacConfig_Mode_value = map[string]int32{
	"OFF":               0,
	"ON":                1,
	"ON_WITH_INCLUSION": 2,
	"ON_WITH_EXCLUSION": 3,
}

func (x RbacConfig_Mode) String() string {
	return proto.EnumName(RbacConfig_Mode_name, int32(x))
}
func (RbacConfig_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{5, 0}
}

// ServiceRole specification contains a list of access rules (permissions).
// This represent the "Spec" part of the ServiceRole object. The name and namespace
// of the ServiceRole is specified in "metadata" section of the ServiceRole object.
// @solo-kit:resource.short_name=svcrole
// @solo-kit:resource.plural_name=service_roles
// @solo-kit:resource.resource_groups=rbac.istio.io
type ServiceRole struct {
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by gloo during validation
	Status core.Status `protobuf:"bytes,100,opt,name=status" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata core.Metadata `protobuf:"bytes,101,opt,name=metadata" json:"metadata"`
	// Required. The set of access rules (permissions) that the role has.
	Rules                []*AccessRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ServiceRole) Reset()         { *m = ServiceRole{} }
func (m *ServiceRole) String() string { return proto.CompactTextString(m) }
func (*ServiceRole) ProtoMessage()    {}
func (*ServiceRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{0}
}
func (m *ServiceRole) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServiceRole.Unmarshal(m, b)
}
func (m *ServiceRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServiceRole.Marshal(b, m, deterministic)
}
func (dst *ServiceRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceRole.Merge(dst, src)
}
func (m *ServiceRole) XXX_Size() int {
	return xxx_messageInfo_ServiceRole.Size(m)
}
func (m *ServiceRole) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceRole.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceRole proto.InternalMessageInfo

func (m *ServiceRole) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *ServiceRole) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

func (m *ServiceRole) GetRules() []*AccessRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// AccessRule defines a permission to access a list of services.
type AccessRule struct {
	// Required. A list of service names.
	// Exact match, prefix match, and suffix match are supported for service names.
	// For example, the service name "bookstore.mtv.cluster.local" matches
	// "bookstore.mtv.cluster.local" (exact match), or "bookstore*" (prefix match),
	// or "*.mtv.cluster.local" (suffix match).
	// If set to ["*"], it refers to all services in the namespace.
	Services []string `protobuf:"bytes,1,rep,name=services" json:"services,omitempty"`
	// Optional. A list of HTTP paths or gRPC methods.
	// gRPC methods must be presented as fully-qualified name in the form of
	// "/packageName.serviceName/methodName" and are case sensitive.
	// Exact match, prefix match, and suffix match are supported for paths.
	// For example, the path "/books/review" matches
	// "/books/review" (exact match), or "/books/*" (prefix match),
	// or "*/review" (suffix match).
	// If not specified, it applies to any path.
	Paths []string `protobuf:"bytes,2,rep,name=paths" json:"paths,omitempty"`
	// Optional. A list of HTTP methods (e.g., "GET", "POST").
	// It is ignored in gRPC case because the value is always "POST".
	// If set to ["*"] or not specified, it applies to any method.
	Methods []string `protobuf:"bytes,3,rep,name=methods" json:"methods,omitempty"`
	// Optional. Extra constraints in the ServiceRole specification.
	// The above ServiceRole example shows an example of constraint "version".
	Constraints          []*AccessRule_Constraint `protobuf:"bytes,4,rep,name=constraints" json:"constraints,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *AccessRule) Reset()         { *m = AccessRule{} }
func (m *AccessRule) String() string { return proto.CompactTextString(m) }
func (*AccessRule) ProtoMessage()    {}
func (*AccessRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{1}
}
func (m *AccessRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccessRule.Unmarshal(m, b)
}
func (m *AccessRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccessRule.Marshal(b, m, deterministic)
}
func (dst *AccessRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRule.Merge(dst, src)
}
func (m *AccessRule) XXX_Size() int {
	return xxx_messageInfo_AccessRule.Size(m)
}
func (m *AccessRule) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRule.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRule proto.InternalMessageInfo

func (m *AccessRule) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *AccessRule) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *AccessRule) GetMethods() []string {
	if m != nil {
		return m.Methods
	}
	return nil
}

func (m *AccessRule) GetConstraints() []*AccessRule_Constraint {
	if m != nil {
		return m.Constraints
	}
	return nil
}

// Definition of a custom constraint. The supported keys are listed in the "constraint and properties" page.
type AccessRule_Constraint struct {
	// Key of the constraint.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// List of valid values for the constraint.
	// Exact match, prefix match, and suffix match are supported for constraint values.
	// For example, the value "v1alpha2" matches
	// "v1alpha2" (exact match), or "v1*" (prefix match),
	// or "*alpha2" (suffix match).
	Values               []string `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessRule_Constraint) Reset()         { *m = AccessRule_Constraint{} }
func (m *AccessRule_Constraint) String() string { return proto.CompactTextString(m) }
func (*AccessRule_Constraint) ProtoMessage()    {}
func (*AccessRule_Constraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{1, 0}
}
func (m *AccessRule_Constraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccessRule_Constraint.Unmarshal(m, b)
}
func (m *AccessRule_Constraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccessRule_Constraint.Marshal(b, m, deterministic)
}
func (dst *AccessRule_Constraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRule_Constraint.Merge(dst, src)
}
func (m *AccessRule_Constraint) XXX_Size() int {
	return xxx_messageInfo_AccessRule_Constraint.Size(m)
}
func (m *AccessRule_Constraint) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRule_Constraint.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRule_Constraint proto.InternalMessageInfo

func (m *AccessRule_Constraint) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *AccessRule_Constraint) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// ServiceRoleBinding assigns a ServiceRole to a list of subjects.
// This represents the "Spec" part of the ServiceRoleBinding object. The name and namespace
// of the ServiceRoleBinding is specified in "metadata" section of the ServiceRoleBinding
// object.
// @solo-kit:resource.short_name=svcrolebind
// @solo-kit:resource.plural_name=service_role_bindings
// @solo-kit:resource.resource_groups=rbac.istio.io
type ServiceRoleBinding struct {
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by gloo during validation
	Status core.Status `protobuf:"bytes,100,opt,name=status" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata core.Metadata `protobuf:"bytes,101,opt,name=metadata" json:"metadata"`
	// Required. List of subjects that are assigned the ServiceRole object.
	Subjects []*Subject `protobuf:"bytes,1,rep,name=subjects" json:"subjects,omitempty"`
	// Required. Reference to the ServiceRole object.
	RoleRef *RoleRef `protobuf:"bytes,2,opt,name=roleRef" json:"roleRef,omitempty"`
	// $hide_from_docs
	// Indicates enforcement mode of the ServiceRoleBinding.
	Mode                 EnforcementMode `protobuf:"varint,3,opt,name=mode,proto3,enum=rbac.istio.io.EnforcementMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ServiceRoleBinding) Reset()         { *m = ServiceRoleBinding{} }
func (m *ServiceRoleBinding) String() string { return proto.CompactTextString(m) }
func (*ServiceRoleBinding) ProtoMessage()    {}
func (*ServiceRoleBinding) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{2}
}
func (m *ServiceRoleBinding) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServiceRoleBinding.Unmarshal(m, b)
}
func (m *ServiceRoleBinding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServiceRoleBinding.Marshal(b, m, deterministic)
}
func (dst *ServiceRoleBinding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceRoleBinding.Merge(dst, src)
}
func (m *ServiceRoleBinding) XXX_Size() int {
	return xxx_messageInfo_ServiceRoleBinding.Size(m)
}
func (m *ServiceRoleBinding) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceRoleBinding.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceRoleBinding proto.InternalMessageInfo

func (m *ServiceRoleBinding) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *ServiceRoleBinding) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

func (m *ServiceRoleBinding) GetSubjects() []*Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *ServiceRoleBinding) GetRoleRef() *RoleRef {
	if m != nil {
		return m.RoleRef
	}
	return nil
}

func (m *ServiceRoleBinding) GetMode() EnforcementMode {
	if m != nil {
		return m.Mode
	}
	return EnforcementMode_ENFORCED
}

// Subject defines an identity. The identity is either a user or identified by a set of `properties`.
// The supported keys in `properties` are listed in "constraint and properties" page.
type Subject struct {
	// Optional. The user name/ID that the subject represents.
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// $hide_from_docs
	// Optional. The group that the subject belongs to.
	Group string `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	// Optional. The set of properties that identify the subject.
	// The above ServiceRoleBinding example shows an example of property "source.namespace".
	Properties           map[string]string `protobuf:"bytes,3,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Subject) Reset()         { *m = Subject{} }
func (m *Subject) String() string { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()    {}
func (*Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{3}
}
func (m *Subject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Subject.Unmarshal(m, b)
}
func (m *Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Subject.Marshal(b, m, deterministic)
}
func (dst *Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject.Merge(dst, src)
}
func (m *Subject) XXX_Size() int {
	return xxx_messageInfo_Subject.Size(m)
}
func (m *Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject.DiscardUnknown(m)
}

var xxx_messageInfo_Subject proto.InternalMessageInfo

func (m *Subject) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Subject) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subject) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

// RoleRef refers to a role object.
type RoleRef struct {
	// Required. The type of the role being referenced.
	// Currently, "ServiceRole" is the only supported value for "kind".
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// Required. The name of the ServiceRole object being referenced.
	// The ServiceRole object must be in the same namespace as the ServiceRoleBinding
	// object.
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoleRef) Reset()         { *m = RoleRef{} }
func (m *RoleRef) String() string { return proto.CompactTextString(m) }
func (*RoleRef) ProtoMessage()    {}
func (*RoleRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{4}
}
func (m *RoleRef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoleRef.Unmarshal(m, b)
}
func (m *RoleRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoleRef.Marshal(b, m, deterministic)
}
func (dst *RoleRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleRef.Merge(dst, src)
}
func (m *RoleRef) XXX_Size() int {
	return xxx_messageInfo_RoleRef.Size(m)
}
func (m *RoleRef) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleRef.DiscardUnknown(m)
}

var xxx_messageInfo_RoleRef proto.InternalMessageInfo

func (m *RoleRef) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *RoleRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// RbacConfig defines the global config to control Istio RBAC behavior.
// This Custom Resource is a singleton where only one Custom Resource should be created globally in
// the mesh and the namespace should be the same to other Istio components, which usually is istio-system.
// Note: This is enforced in both istioctl and server side, new Custom Resource will be rejected if found any
// existing one, the user should either delete the existing one or change the existing one directly.
//
// Below is an example of RbacConfig object "istio-rbac-config" which enables Istio RBAC for all
// services in the default namespace.
//
// ```yaml
// apiVersion: "rbac.istio.io/v1alpha1"
// kind: RbacConfig
// metadata:
//   name: default
//   namespace: istio-system
// spec:
//   mode: ON_WITH_INCLUSION
//   inclusion:
//     namespaces: [ "default" ]
// ```
// @solo-kit:resource.short_name=rbaccfg
// @solo-kit:resource.plural_name=rbac_configs
// @solo-kit:resource.resource_groups=rbac.istio.io
type RbacConfig struct {
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by gloo during validation
	Status core.Status `protobuf:"bytes,100,opt,name=status" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata core.Metadata `protobuf:"bytes,101,opt,name=metadata" json:"metadata"`
	// Istio RBAC mode.
	Mode RbacConfig_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=rbac.istio.io.RbacConfig_Mode" json:"mode,omitempty"`
	// A list of services or namespaces that should be enforced by Istio RBAC policies. Note: This field have
	// effect only when mode is ON_WITH_INCLUSION and will be ignored for any other modes.
	Inclusion *RbacConfig_Target `protobuf:"bytes,2,opt,name=inclusion" json:"inclusion,omitempty"`
	// A list of services or namespaces that should not be enforced by Istio RBAC policies. Note: This field have
	// effect only when mode is ON_WITH_EXCLUSION and will be ignored for any other modes.
	Exclusion *RbacConfig_Target `protobuf:"bytes,3,opt,name=exclusion" json:"exclusion,omitempty"`
	// $hide_from_docs
	// Indicates enforcement mode of the RbacConfig, in ENFORCED mode by default.
	// It's used to verify new RbacConfig work as expected before rolling to production.
	// When setting as PERMISSIVE, RBAC isn't enforced and has no impact on users.
	// RBAC engine run RbacConfig in PERMISSIVE mode and logs stats.
	// Invalid to set RbacConfig in PERMISSIVE and ServiceRoleBinding in ENFORCED mode.
	EnforcementMode      EnforcementMode `protobuf:"varint,4,opt,name=enforcement_mode,json=enforcementMode,proto3,enum=rbac.istio.io.EnforcementMode" json:"enforcement_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RbacConfig) Reset()         { *m = RbacConfig{} }
func (m *RbacConfig) String() string { return proto.CompactTextString(m) }
func (*RbacConfig) ProtoMessage()    {}
func (*RbacConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{5}
}
func (m *RbacConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RbacConfig.Unmarshal(m, b)
}
func (m *RbacConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RbacConfig.Marshal(b, m, deterministic)
}
func (dst *RbacConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RbacConfig.Merge(dst, src)
}
func (m *RbacConfig) XXX_Size() int {
	return xxx_messageInfo_RbacConfig.Size(m)
}
func (m *RbacConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RbacConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RbacConfig proto.InternalMessageInfo

func (m *RbacConfig) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *RbacConfig) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

func (m *RbacConfig) GetMode() RbacConfig_Mode {
	if m != nil {
		return m.Mode
	}
	return RbacConfig_OFF
}

func (m *RbacConfig) GetInclusion() *RbacConfig_Target {
	if m != nil {
		return m.Inclusion
	}
	return nil
}

func (m *RbacConfig) GetExclusion() *RbacConfig_Target {
	if m != nil {
		return m.Exclusion
	}
	return nil
}

func (m *RbacConfig) GetEnforcementMode() EnforcementMode {
	if m != nil {
		return m.EnforcementMode
	}
	return EnforcementMode_ENFORCED
}

// Target defines a list of services or namespaces.
type RbacConfig_Target struct {
	// A list of services.
	Services []string `protobuf:"bytes,1,rep,name=services" json:"services,omitempty"`
	// A list of namespaces.
	Namespaces           []string `protobuf:"bytes,2,rep,name=namespaces" json:"namespaces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RbacConfig_Target) Reset()         { *m = RbacConfig_Target{} }
func (m *RbacConfig_Target) String() string { return proto.CompactTextString(m) }
func (*RbacConfig_Target) ProtoMessage()    {}
func (*RbacConfig_Target) Descriptor() ([]byte, []int) {
	return fileDescriptor_rbac_481c20b7c7f8fc42, []int{5, 0}
}
func (m *RbacConfig_Target) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RbacConfig_Target.Unmarshal(m, b)
}
func (m *RbacConfig_Target) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RbacConfig_Target.Marshal(b, m, deterministic)
}
func (dst *RbacConfig_Target) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RbacConfig_Target.Merge(dst, src)
}
func (m *RbacConfig_Target) XXX_Size() int {
	return xxx_messageInfo_RbacConfig_Target.Size(m)
}
func (m *RbacConfig_Target) XXX_DiscardUnknown() {
	xxx_messageInfo_RbacConfig_Target.DiscardUnknown(m)
}

var xxx_messageInfo_RbacConfig_Target proto.InternalMessageInfo

func (m *RbacConfig_Target) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *RbacConfig_Target) GetNamespaces() []string {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

func init() {
	proto.RegisterType((*ServiceRole)(nil), "rbac.istio.io.ServiceRole")
	proto.RegisterType((*AccessRule)(nil), "rbac.istio.io.AccessRule")
	proto.RegisterType((*AccessRule_Constraint)(nil), "rbac.istio.io.AccessRule.Constraint")
	proto.RegisterType((*ServiceRoleBinding)(nil), "rbac.istio.io.ServiceRoleBinding")
	proto.RegisterType((*Subject)(nil), "rbac.istio.io.Subject")
	proto.RegisterMapType((map[string]string)(nil), "rbac.istio.io.Subject.PropertiesEntry")
	proto.RegisterType((*RoleRef)(nil), "rbac.istio.io.RoleRef")
	proto.RegisterType((*RbacConfig)(nil), "rbac.istio.io.RbacConfig")
	proto.RegisterType((*RbacConfig_Target)(nil), "rbac.istio.io.RbacConfig.Target")
	proto.RegisterEnum("rbac.istio.io.EnforcementMode", EnforcementMode_name, EnforcementMode_value)
	proto.RegisterEnum("rbac.istio.io.RbacConfig_Mode", RbacConfig_Mode_name, RbacConfig_Mode_value)
}
func (this *ServiceRole) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceRole)
	if !ok {
		that2, ok := that.(ServiceRole)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AccessRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessRule)
	if !ok {
		that2, ok := that.(AccessRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if this.Services[i] != that1.Services[i] {
			return false
		}
	}
	if len(this.Paths) != len(that1.Paths) {
		return false
	}
	for i := range this.Paths {
		if this.Paths[i] != that1.Paths[i] {
			return false
		}
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	if len(this.Constraints) != len(that1.Constraints) {
		return false
	}
	for i := range this.Constraints {
		if !this.Constraints[i].Equal(that1.Constraints[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AccessRule_Constraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessRule_Constraint)
	if !ok {
		that2, ok := that.(AccessRule_Constraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ServiceRoleBinding) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceRoleBinding)
	if !ok {
		that2, ok := that.(ServiceRoleBinding)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if len(this.Subjects) != len(that1.Subjects) {
		return false
	}
	for i := range this.Subjects {
		if !this.Subjects[i].Equal(that1.Subjects[i]) {
			return false
		}
	}
	if !this.RoleRef.Equal(that1.RoleRef) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Subject) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Subject)
	if !ok {
		that2, ok := that.(Subject)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if len(this.Properties) != len(that1.Properties) {
		return false
	}
	for i := range this.Properties {
		if this.Properties[i] != that1.Properties[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RoleRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleRef)
	if !ok {
		that2, ok := that.(RoleRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RbacConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RbacConfig)
	if !ok {
		that2, ok := that.(RbacConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.Inclusion.Equal(that1.Inclusion) {
		return false
	}
	if !this.Exclusion.Equal(that1.Exclusion) {
		return false
	}
	if this.EnforcementMode != that1.EnforcementMode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RbacConfig_Target) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RbacConfig_Target)
	if !ok {
		that2, ok := that.(RbacConfig_Target)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Services) != len(that1.Services) {
		return false
	}
	for i := range this.Services {
		if this.Services[i] != that1.Services[i] {
			return false
		}
	}
	if len(this.Namespaces) != len(that1.Namespaces) {
		return false
	}
	for i := range this.Namespaces {
		if this.Namespaces[i] != that1.Namespaces[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}

func init() { proto.RegisterFile("rbac.proto", fileDescriptor_rbac_481c20b7c7f8fc42) }

var fileDescriptor_rbac_481c20b7c7f8fc42 = []byte{
	// 758 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0xcd, 0xae, 0xda, 0x46,
	0x14, 0xbe, 0x06, 0x2e, 0x3f, 0x87, 0x36, 0x97, 0x8c, 0xe8, 0x95, 0xc3, 0xe2, 0x06, 0x59, 0x55,
	0x85, 0x2a, 0xd5, 0x2e, 0x54, 0xaa, 0xa2, 0x48, 0xad, 0x14, 0x88, 0x49, 0x91, 0x7a, 0x21, 0x1a,
	0xd2, 0x1f, 0x75, 0x73, 0x35, 0xd8, 0x83, 0x99, 0x62, 0x3c, 0xd6, 0xcc, 0x18, 0x25, 0xcf, 0xd2,
	0x17, 0xe8, 0xb6, 0xdb, 0xee, 0xba, 0xeb, 0x23, 0x74, 0x95, 0x45, 0x1f, 0xa1, 0x4f, 0x50, 0x79,
	0x6c, 0xf3, 0x27, 0x12, 0xdd, 0x65, 0x56, 0x9c, 0xbf, 0xef, 0xcc, 0x37, 0xe7, 0x3b, 0x78, 0x00,
	0xc4, 0x82, 0x78, 0x76, 0x2c, 0xb8, 0xe2, 0xe8, 0x63, 0x6d, 0x33, 0xa9, 0x18, 0xb7, 0x19, 0xef,
	0xf4, 0x03, 0xa6, 0x56, 0xc9, 0xc2, 0xf6, 0xf8, 0xc6, 0x91, 0x3c, 0xe4, 0x5f, 0x30, 0x9e, 0xfd,
	0xae, 0x99, 0x72, 0x48, 0xcc, 0x9c, 0x6d, 0xdf, 0xd9, 0x50, 0x45, 0x7c, 0xa2, 0x48, 0xd6, 0xa1,
	0xe3, 0xdc, 0x03, 0x22, 0x15, 0x51, 0x89, 0xcc, 0x01, 0xed, 0x80, 0x07, 0x5c, 0x9b, 0x4e, 0x6a,
	0x65, 0x51, 0xeb, 0x2f, 0x03, 0x9a, 0x73, 0x2a, 0xb6, 0xcc, 0xa3, 0x98, 0x87, 0x14, 0xbd, 0x80,
	0x6a, 0x86, 0x32, 0xfd, 0xae, 0xd1, 0x6b, 0x0e, 0xda, 0xb6, 0xc7, 0x05, 0xb5, 0xd3, 0xce, 0x36,
	0xe3, 0xf6, 0x5c, 0xe7, 0x86, 0x8f, 0xfe, 0x7e, 0xfb, 0xf8, 0xe2, 0xbf, 0xb7, 0x8f, 0x1f, 0x2a,
	0x2a, 0x95, 0xcf, 0x96, 0xcb, 0xa7, 0x16, 0x0b, 0x22, 0x2e, 0xa8, 0x85, 0x73, 0x38, 0x7a, 0x02,
	0xf5, 0x82, 0xb1, 0x49, 0x75, 0xab, 0xeb, 0xe3, 0x56, 0xb7, 0x79, 0x76, 0x58, 0x49, 0x9b, 0xe1,
	0x5d, 0x35, 0x72, 0xe0, 0x52, 0x24, 0x21, 0x95, 0xa6, 0xd1, 0x2d, 0xf7, 0x9a, 0x83, 0x47, 0xf6,
	0xd1, 0xac, 0xec, 0x67, 0x9e, 0x47, 0xa5, 0xc4, 0x49, 0x48, 0x71, 0x56, 0x67, 0xfd, 0x63, 0x00,
	0xec, 0xa3, 0xa8, 0x03, 0x75, 0x99, 0xdd, 0x28, 0x6b, 0xd1, 0xc0, 0x3b, 0x1f, 0xb5, 0xe1, 0x32,
	0x26, 0x6a, 0x25, 0xcd, 0x92, 0x4e, 0x64, 0x0e, 0x32, 0xa1, 0xb6, 0xa1, 0x6a, 0xc5, 0x7d, 0x69,
	0x96, 0x75, 0xbc, 0x70, 0xd1, 0x18, 0x9a, 0x1e, 0x8f, 0xa4, 0x12, 0x84, 0x45, 0x4a, 0x9a, 0x15,
	0xcd, 0xe8, 0xd3, 0x77, 0x32, 0xb2, 0x47, 0xbb, 0x62, 0x7c, 0x08, 0xec, 0x7c, 0x0d, 0xb0, 0x4f,
	0xa1, 0x16, 0x94, 0xd7, 0xf4, 0x8d, 0x69, 0x74, 0x8d, 0x5e, 0x03, 0xa7, 0x26, 0xba, 0x86, 0xea,
	0x96, 0x84, 0x09, 0x2d, 0x88, 0xe5, 0x9e, 0xf5, 0x47, 0x09, 0xd0, 0x81, 0x3c, 0x43, 0x16, 0xf9,
	0x2c, 0x0a, 0x3e, 0x04, 0x95, 0x06, 0x50, 0x97, 0xc9, 0xe2, 0x57, 0xea, 0xa9, 0x42, 0xa8, 0xeb,
	0x93, 0xb1, 0xcc, 0xb3, 0x34, 0xde, 0xd5, 0xa1, 0x2f, 0xa1, 0x26, 0x78, 0x48, 0x31, 0x5d, 0x9a,
	0xa5, 0xfc, 0xb0, 0x63, 0x08, 0xce, 0xb2, 0xb8, 0x28, 0x43, 0x03, 0xa8, 0x6c, 0xb8, 0x4f, 0xcd,
	0x72, 0xd7, 0xe8, 0x3d, 0x18, 0xdc, 0x9c, 0x94, 0xbb, 0xd1, 0x92, 0x0b, 0x8f, 0x6e, 0x68, 0xa4,
	0x6e, 0xb9, 0x4f, 0xb1, 0xae, 0xb5, 0xfe, 0x34, 0xa0, 0x96, 0x9f, 0x8d, 0x10, 0x54, 0x12, 0x49,
	0x45, 0x3e, 0x6a, 0x6d, 0xa7, 0x3b, 0x10, 0x08, 0x9e, 0xc4, 0x9a, 0x43, 0x03, 0x67, 0x0e, 0x1a,
	0x03, 0xc4, 0x82, 0xc7, 0x54, 0x28, 0x46, 0xb3, 0x35, 0x68, 0x0e, 0x3e, 0x3b, 0x7f, 0x23, 0xfb,
	0xe5, 0xae, 0xd0, 0x8d, 0x94, 0x78, 0x83, 0x0f, 0x90, 0x9d, 0x6f, 0xe0, 0xea, 0x24, 0x7d, 0x46,
	0xee, 0x36, 0x5c, 0x6a, 0x81, 0x0b, 0x0a, 0xda, 0x79, 0x5a, 0x7a, 0x62, 0x58, 0x7d, 0xa8, 0xe5,
	0x43, 0x48, 0xb9, 0xaf, 0x59, 0xe4, 0x17, 0xdc, 0x53, 0x3b, 0x8d, 0x45, 0x64, 0x53, 0xe0, 0xb4,
	0x6d, 0xfd, 0x56, 0x01, 0xc0, 0x0b, 0xe2, 0x8d, 0x78, 0xb4, 0x64, 0x1f, 0xc8, 0x6e, 0x64, 0xaa,
	0x19, 0x67, 0x55, 0xdb, 0x73, 0xb5, 0xf7, 0xaa, 0xa1, 0x6f, 0xa1, 0xc1, 0x22, 0x2f, 0x4c, 0x24,
	0xe3, 0x51, 0xbe, 0x1d, 0xdd, 0x77, 0x03, 0x5f, 0x11, 0x11, 0x50, 0x85, 0xf7, 0x90, 0x14, 0x4f,
	0x5f, 0x17, 0xf8, 0xf2, 0x7d, 0xf1, 0x3b, 0x08, 0x9a, 0x40, 0x8b, 0xee, 0xd7, 0xe9, 0x4e, 0xf3,
	0xaf, 0xdc, 0x6b, 0xeb, 0xae, 0xe8, 0x71, 0xa0, 0xf3, 0x1c, 0xaa, 0x59, 0xff, 0xf7, 0x7e, 0x8a,
	0x6e, 0x00, 0x52, 0xf9, 0x64, 0x4c, 0xbc, 0xdd, 0xdf, 0xfe, 0x20, 0x62, 0xb9, 0x50, 0x49, 0xbb,
	0xa1, 0x1a, 0x94, 0x67, 0xe3, 0x71, 0xeb, 0x02, 0x55, 0xa1, 0x34, 0x9b, 0xb6, 0x0c, 0xf4, 0x09,
	0x3c, 0x9c, 0x4d, 0xef, 0x7e, 0x9a, 0xbc, 0xfa, 0xee, 0x6e, 0x32, 0x1d, 0x7d, 0xff, 0xc3, 0x7c,
	0x32, 0x9b, 0xb6, 0x4a, 0x87, 0x61, 0xf7, 0xe7, 0x22, 0x5c, 0xfe, 0xdc, 0x81, 0xab, 0x13, 0xc2,
	0xe8, 0x23, 0xa8, 0xbb, 0xd3, 0xf1, 0x0c, 0x8f, 0xdc, 0xe7, 0xad, 0x0b, 0xf4, 0x00, 0xe0, 0xa5,
	0x8b, 0x6f, 0x27, 0xf3, 0xf9, 0xe4, 0x47, 0xb7, 0x65, 0x0c, 0x5f, 0xfc, 0xfe, 0xef, 0x8d, 0xf1,
	0xcb, 0xb3, 0x73, 0xcf, 0x4b, 0x12, 0x53, 0x11, 0x84, 0x9c, 0x3b, 0xf1, 0x3a, 0xd0, 0x6f, 0x0c,
	0x7d, 0xad, 0xa8, 0x88, 0x48, 0xe8, 0xe8, 0xe1, 0x38, 0xe9, 0x9c, 0x9c, 0x6d, 0x9f, 0x84, 0xf1,
	0x8a, 0xf4, 0x17, 0x55, 0xfd, 0xc2, 0x7c, 0xf5, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x97, 0x66,
	0x9c, 0xbb, 0xf8, 0x06, 0x00, 0x00,
}
