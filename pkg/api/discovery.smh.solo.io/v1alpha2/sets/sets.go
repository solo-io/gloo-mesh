// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1alpha2sets

import (
	discovery_smh_solo_io_v1alpha2 "github.com/solo-io/service-mesh-hub/pkg/api/discovery.smh.solo.io/v1alpha2"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type TrafficTargetSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.TrafficTarget) bool) []*discovery_smh_solo_io_v1alpha2.TrafficTarget
	// Return the Set as a map of key to resource.
	Map() map[string]*discovery_smh_solo_io_v1alpha2.TrafficTarget
	// Insert a resource into the set.
	Insert(trafficTarget ...*discovery_smh_solo_io_v1alpha2.TrafficTarget)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(trafficTargetSet TrafficTargetSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(trafficTarget ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(trafficTarget ezkube.ResourceId)
	// Return the union with the provided set
	Union(set TrafficTargetSet) TrafficTargetSet
	// Return the difference with the provided set
	Difference(set TrafficTargetSet) TrafficTargetSet
	// Return the intersection with the provided set
	Intersection(set TrafficTargetSet) TrafficTargetSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.TrafficTarget, error)
	// Get the length of the set
	Length() int
}

func makeGenericTrafficTargetSet(trafficTargetList []*discovery_smh_solo_io_v1alpha2.TrafficTarget) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range trafficTargetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type trafficTargetSet struct {
	set sksets.ResourceSet
}

func NewTrafficTargetSet(trafficTargetList ...*discovery_smh_solo_io_v1alpha2.TrafficTarget) TrafficTargetSet {
	return &trafficTargetSet{set: makeGenericTrafficTargetSet(trafficTargetList)}
}

func NewTrafficTargetSetFromList(trafficTargetList *discovery_smh_solo_io_v1alpha2.TrafficTargetList) TrafficTargetSet {
	list := make([]*discovery_smh_solo_io_v1alpha2.TrafficTarget, 0, len(trafficTargetList.Items))
	for idx := range trafficTargetList.Items {
		list = append(list, &trafficTargetList.Items[idx])
	}
	return &trafficTargetSet{set: makeGenericTrafficTargetSet(list)}
}

func (s *trafficTargetSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *trafficTargetSet) List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.TrafficTarget) bool) []*discovery_smh_solo_io_v1alpha2.TrafficTarget {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*discovery_smh_solo_io_v1alpha2.TrafficTarget))
		})
	}

	var trafficTargetList []*discovery_smh_solo_io_v1alpha2.TrafficTarget
	for _, obj := range s.set.List(genericFilters...) {
		trafficTargetList = append(trafficTargetList, obj.(*discovery_smh_solo_io_v1alpha2.TrafficTarget))
	}
	return trafficTargetList
}

func (s *trafficTargetSet) Map() map[string]*discovery_smh_solo_io_v1alpha2.TrafficTarget {
	if s == nil {
		return nil
	}

	newMap := map[string]*discovery_smh_solo_io_v1alpha2.TrafficTarget{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*discovery_smh_solo_io_v1alpha2.TrafficTarget)
	}
	return newMap
}

func (s *trafficTargetSet) Insert(
	trafficTargetList ...*discovery_smh_solo_io_v1alpha2.TrafficTarget,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range trafficTargetList {
		s.set.Insert(obj)
	}
}

func (s *trafficTargetSet) Has(trafficTarget ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(trafficTarget)
}

func (s *trafficTargetSet) Equal(
	trafficTargetSet TrafficTargetSet,
) bool {
	if s == nil {
		return trafficTargetSet == nil
	}
	return s.set.Equal(makeGenericTrafficTargetSet(trafficTargetSet.List()))
}

func (s *trafficTargetSet) Delete(TrafficTarget ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(TrafficTarget)
}

func (s *trafficTargetSet) Union(set TrafficTargetSet) TrafficTargetSet {
	if s == nil {
		return set
	}
	return NewTrafficTargetSet(append(s.List(), set.List()...)...)
}

func (s *trafficTargetSet) Difference(set TrafficTargetSet) TrafficTargetSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericTrafficTargetSet(set.List()))
	return &trafficTargetSet{set: newSet}
}

func (s *trafficTargetSet) Intersection(set TrafficTargetSet) TrafficTargetSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericTrafficTargetSet(set.List()))
	var trafficTargetList []*discovery_smh_solo_io_v1alpha2.TrafficTarget
	for _, obj := range newSet.List() {
		trafficTargetList = append(trafficTargetList, obj.(*discovery_smh_solo_io_v1alpha2.TrafficTarget))
	}
	return NewTrafficTargetSet(trafficTargetList...)
}

func (s *trafficTargetSet) Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.TrafficTarget, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find TrafficTarget %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&discovery_smh_solo_io_v1alpha2.TrafficTarget{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*discovery_smh_solo_io_v1alpha2.TrafficTarget), nil
}

func (s *trafficTargetSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}

type MeshWorkloadSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.MeshWorkload) bool) []*discovery_smh_solo_io_v1alpha2.MeshWorkload
	// Return the Set as a map of key to resource.
	Map() map[string]*discovery_smh_solo_io_v1alpha2.MeshWorkload
	// Insert a resource into the set.
	Insert(meshWorkload ...*discovery_smh_solo_io_v1alpha2.MeshWorkload)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(meshWorkloadSet MeshWorkloadSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(meshWorkload ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(meshWorkload ezkube.ResourceId)
	// Return the union with the provided set
	Union(set MeshWorkloadSet) MeshWorkloadSet
	// Return the difference with the provided set
	Difference(set MeshWorkloadSet) MeshWorkloadSet
	// Return the intersection with the provided set
	Intersection(set MeshWorkloadSet) MeshWorkloadSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.MeshWorkload, error)
	// Get the length of the set
	Length() int
}

func makeGenericMeshWorkloadSet(meshWorkloadList []*discovery_smh_solo_io_v1alpha2.MeshWorkload) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range meshWorkloadList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type meshWorkloadSet struct {
	set sksets.ResourceSet
}

func NewMeshWorkloadSet(meshWorkloadList ...*discovery_smh_solo_io_v1alpha2.MeshWorkload) MeshWorkloadSet {
	return &meshWorkloadSet{set: makeGenericMeshWorkloadSet(meshWorkloadList)}
}

func NewMeshWorkloadSetFromList(meshWorkloadList *discovery_smh_solo_io_v1alpha2.MeshWorkloadList) MeshWorkloadSet {
	list := make([]*discovery_smh_solo_io_v1alpha2.MeshWorkload, 0, len(meshWorkloadList.Items))
	for idx := range meshWorkloadList.Items {
		list = append(list, &meshWorkloadList.Items[idx])
	}
	return &meshWorkloadSet{set: makeGenericMeshWorkloadSet(list)}
}

func (s *meshWorkloadSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *meshWorkloadSet) List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.MeshWorkload) bool) []*discovery_smh_solo_io_v1alpha2.MeshWorkload {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload))
		})
	}

	var meshWorkloadList []*discovery_smh_solo_io_v1alpha2.MeshWorkload
	for _, obj := range s.set.List(genericFilters...) {
		meshWorkloadList = append(meshWorkloadList, obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload))
	}
	return meshWorkloadList
}

func (s *meshWorkloadSet) Map() map[string]*discovery_smh_solo_io_v1alpha2.MeshWorkload {
	if s == nil {
		return nil
	}

	newMap := map[string]*discovery_smh_solo_io_v1alpha2.MeshWorkload{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*discovery_smh_solo_io_v1alpha2.MeshWorkload)
	}
	return newMap
}

func (s *meshWorkloadSet) Insert(
	meshWorkloadList ...*discovery_smh_solo_io_v1alpha2.MeshWorkload,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range meshWorkloadList {
		s.set.Insert(obj)
	}
}

func (s *meshWorkloadSet) Has(meshWorkload ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(meshWorkload)
}

func (s *meshWorkloadSet) Equal(
	meshWorkloadSet MeshWorkloadSet,
) bool {
	if s == nil {
		return meshWorkloadSet == nil
	}
	return s.set.Equal(makeGenericMeshWorkloadSet(meshWorkloadSet.List()))
}

func (s *meshWorkloadSet) Delete(MeshWorkload ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(MeshWorkload)
}

func (s *meshWorkloadSet) Union(set MeshWorkloadSet) MeshWorkloadSet {
	if s == nil {
		return set
	}
	return NewMeshWorkloadSet(append(s.List(), set.List()...)...)
}

func (s *meshWorkloadSet) Difference(set MeshWorkloadSet) MeshWorkloadSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericMeshWorkloadSet(set.List()))
	return &meshWorkloadSet{set: newSet}
}

func (s *meshWorkloadSet) Intersection(set MeshWorkloadSet) MeshWorkloadSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericMeshWorkloadSet(set.List()))
	var meshWorkloadList []*discovery_smh_solo_io_v1alpha2.MeshWorkload
	for _, obj := range newSet.List() {
		meshWorkloadList = append(meshWorkloadList, obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload))
	}
	return NewMeshWorkloadSet(meshWorkloadList...)
}

func (s *meshWorkloadSet) Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.MeshWorkload, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find MeshWorkload %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&discovery_smh_solo_io_v1alpha2.MeshWorkload{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload), nil
}

func (s *meshWorkloadSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}

type MeshSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.Mesh) bool) []*discovery_smh_solo_io_v1alpha2.Mesh
	// Return the Set as a map of key to resource.
	Map() map[string]*discovery_smh_solo_io_v1alpha2.Mesh
	// Insert a resource into the set.
	Insert(mesh ...*discovery_smh_solo_io_v1alpha2.Mesh)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(meshSet MeshSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(mesh ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(mesh ezkube.ResourceId)
	// Return the union with the provided set
	Union(set MeshSet) MeshSet
	// Return the difference with the provided set
	Difference(set MeshSet) MeshSet
	// Return the intersection with the provided set
	Intersection(set MeshSet) MeshSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.Mesh, error)
	// Get the length of the set
	Length() int
}

func makeGenericMeshSet(meshList []*discovery_smh_solo_io_v1alpha2.Mesh) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range meshList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type meshSet struct {
	set sksets.ResourceSet
}

func NewMeshSet(meshList ...*discovery_smh_solo_io_v1alpha2.Mesh) MeshSet {
	return &meshSet{set: makeGenericMeshSet(meshList)}
}

func NewMeshSetFromList(meshList *discovery_smh_solo_io_v1alpha2.MeshList) MeshSet {
	list := make([]*discovery_smh_solo_io_v1alpha2.Mesh, 0, len(meshList.Items))
	for idx := range meshList.Items {
		list = append(list, &meshList.Items[idx])
	}
	return &meshSet{set: makeGenericMeshSet(list)}
}

func (s *meshSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *meshSet) List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.Mesh) bool) []*discovery_smh_solo_io_v1alpha2.Mesh {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*discovery_smh_solo_io_v1alpha2.Mesh))
		})
	}

	var meshList []*discovery_smh_solo_io_v1alpha2.Mesh
	for _, obj := range s.set.List(genericFilters...) {
		meshList = append(meshList, obj.(*discovery_smh_solo_io_v1alpha2.Mesh))
	}
	return meshList
}

func (s *meshSet) Map() map[string]*discovery_smh_solo_io_v1alpha2.Mesh {
	if s == nil {
		return nil
	}

	newMap := map[string]*discovery_smh_solo_io_v1alpha2.Mesh{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*discovery_smh_solo_io_v1alpha2.Mesh)
	}
	return newMap
}

func (s *meshSet) Insert(
	meshList ...*discovery_smh_solo_io_v1alpha2.Mesh,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range meshList {
		s.set.Insert(obj)
	}
}

func (s *meshSet) Has(mesh ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(mesh)
}

func (s *meshSet) Equal(
	meshSet MeshSet,
) bool {
	if s == nil {
		return meshSet == nil
	}
	return s.set.Equal(makeGenericMeshSet(meshSet.List()))
}

func (s *meshSet) Delete(Mesh ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(Mesh)
}

func (s *meshSet) Union(set MeshSet) MeshSet {
	if s == nil {
		return set
	}
	return NewMeshSet(append(s.List(), set.List()...)...)
}

func (s *meshSet) Difference(set MeshSet) MeshSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericMeshSet(set.List()))
	return &meshSet{set: newSet}
}

func (s *meshSet) Intersection(set MeshSet) MeshSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericMeshSet(set.List()))
	var meshList []*discovery_smh_solo_io_v1alpha2.Mesh
	for _, obj := range newSet.List() {
		meshList = append(meshList, obj.(*discovery_smh_solo_io_v1alpha2.Mesh))
	}
	return NewMeshSet(meshList...)
}

func (s *meshSet) Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.Mesh, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Mesh %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&discovery_smh_solo_io_v1alpha2.Mesh{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*discovery_smh_solo_io_v1alpha2.Mesh), nil
}

func (s *meshSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}
