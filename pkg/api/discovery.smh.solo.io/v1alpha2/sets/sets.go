// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1alpha2sets

import (
	discovery_smh_solo_io_v1alpha2 "github.com/solo-io/service-mesh-hub/pkg/api/discovery.smh.solo.io/v1alpha2"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type MeshServiceSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.MeshService) bool) []*discovery_smh_solo_io_v1alpha2.MeshService
	// Return the Set as a map of key to resource.
	Map() map[string]*discovery_smh_solo_io_v1alpha2.MeshService
	// Insert a resource into the set.
	Insert(meshService ...*discovery_smh_solo_io_v1alpha2.MeshService)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(meshServiceSet MeshServiceSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(meshService ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(meshService ezkube.ResourceId)
	// Return the union with the provided set
	Union(set MeshServiceSet) MeshServiceSet
	// Return the difference with the provided set
	Difference(set MeshServiceSet) MeshServiceSet
	// Return the intersection with the provided set
	Intersection(set MeshServiceSet) MeshServiceSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.MeshService, error)
	// Get the length of the set
	Length() int
}

func makeGenericMeshServiceSet(meshServiceList []*discovery_smh_solo_io_v1alpha2.MeshService) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range meshServiceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type meshServiceSet struct {
	set sksets.ResourceSet
}

func NewMeshServiceSet(meshServiceList ...*discovery_smh_solo_io_v1alpha2.MeshService) MeshServiceSet {
	return &meshServiceSet{set: makeGenericMeshServiceSet(meshServiceList)}
}

func NewMeshServiceSetFromList(meshServiceList *discovery_smh_solo_io_v1alpha2.MeshServiceList) MeshServiceSet {
	list := make([]*discovery_smh_solo_io_v1alpha2.MeshService, 0, len(meshServiceList.Items))
	for idx := range meshServiceList.Items {
		list = append(list, &meshServiceList.Items[idx])
	}
	return &meshServiceSet{set: makeGenericMeshServiceSet(list)}
}

func (s *meshServiceSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *meshServiceSet) List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.MeshService) bool) []*discovery_smh_solo_io_v1alpha2.MeshService {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*discovery_smh_solo_io_v1alpha2.MeshService))
		})
	}

	var meshServiceList []*discovery_smh_solo_io_v1alpha2.MeshService
	for _, obj := range s.set.List(genericFilters...) {
		meshServiceList = append(meshServiceList, obj.(*discovery_smh_solo_io_v1alpha2.MeshService))
	}
	return meshServiceList
}

func (s *meshServiceSet) Map() map[string]*discovery_smh_solo_io_v1alpha2.MeshService {
	if s == nil {
		return nil
	}

	newMap := map[string]*discovery_smh_solo_io_v1alpha2.MeshService{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*discovery_smh_solo_io_v1alpha2.MeshService)
	}
	return newMap
}

func (s *meshServiceSet) Insert(
	meshServiceList ...*discovery_smh_solo_io_v1alpha2.MeshService,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range meshServiceList {
		s.set.Insert(obj)
	}
}

func (s *meshServiceSet) Has(meshService ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(meshService)
}

func (s *meshServiceSet) Equal(
	meshServiceSet MeshServiceSet,
) bool {
	if s == nil {
		return meshServiceSet == nil
	}
	return s.set.Equal(makeGenericMeshServiceSet(meshServiceSet.List()))
}

func (s *meshServiceSet) Delete(MeshService ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(MeshService)
}

func (s *meshServiceSet) Union(set MeshServiceSet) MeshServiceSet {
	if s == nil {
		return set
	}
	return NewMeshServiceSet(append(s.List(), set.List()...)...)
}

func (s *meshServiceSet) Difference(set MeshServiceSet) MeshServiceSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericMeshServiceSet(set.List()))
	return &meshServiceSet{set: newSet}
}

func (s *meshServiceSet) Intersection(set MeshServiceSet) MeshServiceSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericMeshServiceSet(set.List()))
	var meshServiceList []*discovery_smh_solo_io_v1alpha2.MeshService
	for _, obj := range newSet.List() {
		meshServiceList = append(meshServiceList, obj.(*discovery_smh_solo_io_v1alpha2.MeshService))
	}
	return NewMeshServiceSet(meshServiceList...)
}

func (s *meshServiceSet) Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.MeshService, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find MeshService %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&discovery_smh_solo_io_v1alpha2.MeshService{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*discovery_smh_solo_io_v1alpha2.MeshService), nil
}

func (s *meshServiceSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}

type MeshWorkloadSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.MeshWorkload) bool) []*discovery_smh_solo_io_v1alpha2.MeshWorkload
	// Return the Set as a map of key to resource.
	Map() map[string]*discovery_smh_solo_io_v1alpha2.MeshWorkload
	// Insert a resource into the set.
	Insert(meshWorkload ...*discovery_smh_solo_io_v1alpha2.MeshWorkload)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(meshWorkloadSet MeshWorkloadSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(meshWorkload ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(meshWorkload ezkube.ResourceId)
	// Return the union with the provided set
	Union(set MeshWorkloadSet) MeshWorkloadSet
	// Return the difference with the provided set
	Difference(set MeshWorkloadSet) MeshWorkloadSet
	// Return the intersection with the provided set
	Intersection(set MeshWorkloadSet) MeshWorkloadSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.MeshWorkload, error)
	// Get the length of the set
	Length() int
}

func makeGenericMeshWorkloadSet(meshWorkloadList []*discovery_smh_solo_io_v1alpha2.MeshWorkload) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range meshWorkloadList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type meshWorkloadSet struct {
	set sksets.ResourceSet
}

func NewMeshWorkloadSet(meshWorkloadList ...*discovery_smh_solo_io_v1alpha2.MeshWorkload) MeshWorkloadSet {
	return &meshWorkloadSet{set: makeGenericMeshWorkloadSet(meshWorkloadList)}
}

func NewMeshWorkloadSetFromList(meshWorkloadList *discovery_smh_solo_io_v1alpha2.MeshWorkloadList) MeshWorkloadSet {
	list := make([]*discovery_smh_solo_io_v1alpha2.MeshWorkload, 0, len(meshWorkloadList.Items))
	for idx := range meshWorkloadList.Items {
		list = append(list, &meshWorkloadList.Items[idx])
	}
	return &meshWorkloadSet{set: makeGenericMeshWorkloadSet(list)}
}

func (s *meshWorkloadSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *meshWorkloadSet) List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.MeshWorkload) bool) []*discovery_smh_solo_io_v1alpha2.MeshWorkload {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload))
		})
	}

	var meshWorkloadList []*discovery_smh_solo_io_v1alpha2.MeshWorkload
	for _, obj := range s.set.List(genericFilters...) {
		meshWorkloadList = append(meshWorkloadList, obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload))
	}
	return meshWorkloadList
}

func (s *meshWorkloadSet) Map() map[string]*discovery_smh_solo_io_v1alpha2.MeshWorkload {
	if s == nil {
		return nil
	}

	newMap := map[string]*discovery_smh_solo_io_v1alpha2.MeshWorkload{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*discovery_smh_solo_io_v1alpha2.MeshWorkload)
	}
	return newMap
}

func (s *meshWorkloadSet) Insert(
	meshWorkloadList ...*discovery_smh_solo_io_v1alpha2.MeshWorkload,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range meshWorkloadList {
		s.set.Insert(obj)
	}
}

func (s *meshWorkloadSet) Has(meshWorkload ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(meshWorkload)
}

func (s *meshWorkloadSet) Equal(
	meshWorkloadSet MeshWorkloadSet,
) bool {
	if s == nil {
		return meshWorkloadSet == nil
	}
	return s.set.Equal(makeGenericMeshWorkloadSet(meshWorkloadSet.List()))
}

func (s *meshWorkloadSet) Delete(MeshWorkload ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(MeshWorkload)
}

func (s *meshWorkloadSet) Union(set MeshWorkloadSet) MeshWorkloadSet {
	if s == nil {
		return set
	}
	return NewMeshWorkloadSet(append(s.List(), set.List()...)...)
}

func (s *meshWorkloadSet) Difference(set MeshWorkloadSet) MeshWorkloadSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericMeshWorkloadSet(set.List()))
	return &meshWorkloadSet{set: newSet}
}

func (s *meshWorkloadSet) Intersection(set MeshWorkloadSet) MeshWorkloadSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericMeshWorkloadSet(set.List()))
	var meshWorkloadList []*discovery_smh_solo_io_v1alpha2.MeshWorkload
	for _, obj := range newSet.List() {
		meshWorkloadList = append(meshWorkloadList, obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload))
	}
	return NewMeshWorkloadSet(meshWorkloadList...)
}

func (s *meshWorkloadSet) Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.MeshWorkload, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find MeshWorkload %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&discovery_smh_solo_io_v1alpha2.MeshWorkload{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*discovery_smh_solo_io_v1alpha2.MeshWorkload), nil
}

func (s *meshWorkloadSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}

type MeshSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.Mesh) bool) []*discovery_smh_solo_io_v1alpha2.Mesh
	// Return the Set as a map of key to resource.
	Map() map[string]*discovery_smh_solo_io_v1alpha2.Mesh
	// Insert a resource into the set.
	Insert(mesh ...*discovery_smh_solo_io_v1alpha2.Mesh)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(meshSet MeshSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(mesh ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(mesh ezkube.ResourceId)
	// Return the union with the provided set
	Union(set MeshSet) MeshSet
	// Return the difference with the provided set
	Difference(set MeshSet) MeshSet
	// Return the intersection with the provided set
	Intersection(set MeshSet) MeshSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.Mesh, error)
	// Get the length of the set
	Length() int
}

func makeGenericMeshSet(meshList []*discovery_smh_solo_io_v1alpha2.Mesh) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range meshList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type meshSet struct {
	set sksets.ResourceSet
}

func NewMeshSet(meshList ...*discovery_smh_solo_io_v1alpha2.Mesh) MeshSet {
	return &meshSet{set: makeGenericMeshSet(meshList)}
}

func NewMeshSetFromList(meshList *discovery_smh_solo_io_v1alpha2.MeshList) MeshSet {
	list := make([]*discovery_smh_solo_io_v1alpha2.Mesh, 0, len(meshList.Items))
	for idx := range meshList.Items {
		list = append(list, &meshList.Items[idx])
	}
	return &meshSet{set: makeGenericMeshSet(list)}
}

func (s *meshSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *meshSet) List(filterResource ...func(*discovery_smh_solo_io_v1alpha2.Mesh) bool) []*discovery_smh_solo_io_v1alpha2.Mesh {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*discovery_smh_solo_io_v1alpha2.Mesh))
		})
	}

	var meshList []*discovery_smh_solo_io_v1alpha2.Mesh
	for _, obj := range s.set.List(genericFilters...) {
		meshList = append(meshList, obj.(*discovery_smh_solo_io_v1alpha2.Mesh))
	}
	return meshList
}

func (s *meshSet) Map() map[string]*discovery_smh_solo_io_v1alpha2.Mesh {
	if s == nil {
		return nil
	}

	newMap := map[string]*discovery_smh_solo_io_v1alpha2.Mesh{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*discovery_smh_solo_io_v1alpha2.Mesh)
	}
	return newMap
}

func (s *meshSet) Insert(
	meshList ...*discovery_smh_solo_io_v1alpha2.Mesh,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range meshList {
		s.set.Insert(obj)
	}
}

func (s *meshSet) Has(mesh ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(mesh)
}

func (s *meshSet) Equal(
	meshSet MeshSet,
) bool {
	if s == nil {
		return meshSet == nil
	}
	return s.set.Equal(makeGenericMeshSet(meshSet.List()))
}

func (s *meshSet) Delete(Mesh ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(Mesh)
}

func (s *meshSet) Union(set MeshSet) MeshSet {
	if s == nil {
		return set
	}
	return NewMeshSet(append(s.List(), set.List()...)...)
}

func (s *meshSet) Difference(set MeshSet) MeshSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericMeshSet(set.List()))
	return &meshSet{set: newSet}
}

func (s *meshSet) Intersection(set MeshSet) MeshSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericMeshSet(set.List()))
	var meshList []*discovery_smh_solo_io_v1alpha2.Mesh
	for _, obj := range newSet.List() {
		meshList = append(meshList, obj.(*discovery_smh_solo_io_v1alpha2.Mesh))
	}
	return NewMeshSet(meshList...)
}

func (s *meshSet) Find(id ezkube.ResourceId) (*discovery_smh_solo_io_v1alpha2.Mesh, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Mesh %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&discovery_smh_solo_io_v1alpha2.Mesh{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*discovery_smh_solo_io_v1alpha2.Mesh), nil
}

func (s *meshSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}
