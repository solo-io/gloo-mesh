// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./remote_snapshot.go -destination mocks/remote_snapshot.go




// The Input RemoteSnapshot contains the set of all:
// * IssuedCertificates
// * PodBounceDirectives
// * XdsConfigs
// * DestinationRules
// * EnvoyFilters
// * Gateways
// * ServiceEntries
// * VirtualServices
// * Sidecars
// * AuthorizationPolicies
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the RemoteSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
    "context"
    "encoding/json"

    "k8s.io/apimachinery/pkg/runtime/schema"
    "github.com/solo-io/skv2/pkg/resource"
    "github.com/solo-io/skv2/pkg/verifier"

    "github.com/hashicorp/go-multierror"




    "github.com/solo-io/skv2/pkg/controllerutils"
    "github.com/solo-io/skv2/pkg/multicluster"
    "sigs.k8s.io/controller-runtime/pkg/manager"
    "sigs.k8s.io/controller-runtime/pkg/client"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/resource"
	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime/schema"


    certificates_mesh_gloo_solo_io_v1_types "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1"
    certificates_mesh_gloo_solo_io_v1 "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1"
    certificates_mesh_gloo_solo_io_v1_sets "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1/sets"



    xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_types "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1beta1"
    xds_agent_enterprise_mesh_gloo_solo_io_v1beta1 "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1beta1"
    xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1beta1/sets"



    networking_istio_io_v1alpha3_types "istio.io/client-go/pkg/apis/networking/v1alpha3"
    networking_istio_io_v1alpha3 "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3"
    networking_istio_io_v1alpha3_sets "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3/sets"



    security_istio_io_v1beta1_types "istio.io/client-go/pkg/apis/security/v1beta1"
    security_istio_io_v1beta1 "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1"
    security_istio_io_v1beta1_sets "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1/sets"

)

// SnapshotGVKs is a list of the GVKs included in this snapshot
var RemoteSnapshotGVKs = []schema.GroupVersionKind{

	schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "IssuedCertificate",
	},
	schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "PodBounceDirective",
	},

	schema.GroupVersionKind{
		Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "XdsConfig",
	},

	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "DestinationRule",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "EnvoyFilter",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "Gateway",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "ServiceEntry",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "VirtualService",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "Sidecar",
	},

	schema.GroupVersionKind{
		Group:   "security.istio.io",
		Version: "v1beta1",
		Kind:    "AuthorizationPolicy",
	},
}










	schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "IssuedCertificate",
	},
	schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1",
		Kind:    "PodBounceDirective",
	},

	schema.GroupVersionKind{
		Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
		Version: "v1beta1",
		Kind:    "XdsConfig",
	},

	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "DestinationRule",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "EnvoyFilter",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "Gateway",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "ServiceEntry",
	},
	schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "VirtualService",
	},

	schema.GroupVersionKind{
		Group:   "security.istio.io",
		Version: "v1beta1",
		Kind:    "AuthorizationPolicy",
	},
}











// the snapshot of input resources consumed by translation
type RemoteSnapshot interface {

	// return the set of input IssuedCertificates
	IssuedCertificates() certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet
	// return the set of input PodBounceDirectives
	PodBounceDirectives() certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet

	// return the set of input XdsConfigs
	XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet

	// return the set of input DestinationRules
	DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet
	// return the set of input EnvoyFilters
	EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	// return the set of input Gateways
	Gateways() networking_istio_io_v1alpha3_sets.GatewaySet
	// return the set of input ServiceEntries
	ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet
	// return the set of input VirtualServices
	VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet
	// return the set of input Sidecars
	Sidecars() networking_istio_io_v1alpha3_sets.SidecarSet

	// return the set of input AuthorizationPolicies
	AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet
	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts RemoteSyncStatusOptions) error
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts RemoteSyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

// options for syncing input object statuses
type RemoteSyncStatusOptions struct {

	// sync status of IssuedCertificate objects
	IssuedCertificate bool
	// sync status of PodBounceDirective objects
	PodBounceDirective bool

	// sync status of XdsConfig objects
	XdsConfig bool

	// sync status of DestinationRule objects
	DestinationRule bool
	// sync status of EnvoyFilter objects
	EnvoyFilter bool
	// sync status of Gateway objects
	Gateway bool
	// sync status of ServiceEntry objects
	ServiceEntry bool
	// sync status of VirtualService objects
	VirtualService bool
	// sync status of Sidecar objects
	Sidecar bool

	// sync status of AuthorizationPolicy objects
	AuthorizationPolicy bool
}

type snapshotRemote struct {
    name string


    issuedCertificates certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet
    podBounceDirectives certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet

	destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet
	envoyFilters     networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	gateways         networking_istio_io_v1alpha3_sets.GatewaySet
	serviceEntries   networking_istio_io_v1alpha3_sets.ServiceEntrySet
	virtualServices  networking_istio_io_v1alpha3_sets.VirtualServiceSet
	sidecars         networking_istio_io_v1alpha3_sets.SidecarSet

}

func NewRemoteSnapshot(
	name string,


    issuedCertificates certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet,
    podBounceDirectives certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet,

    xdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet,

	destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,
	sidecars networking_istio_io_v1alpha3_sets.SidecarSet,

    authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

) RemoteSnapshot {
	return &snapshotRemote{
		name: name,

		issuedCertificates:    issuedCertificates,
		podBounceDirectives:   podBounceDirectives,
		xdsConfigs:            xdsConfigs,
		destinationRules:      destinationRules,
		envoyFilters:          envoyFilters,
		gateways:              gateways,
		serviceEntries:        serviceEntries,
		virtualServices:       virtualServices,
		sidecars:              sidecars,
		authorizationPolicies: authorizationPolicies,
	}
}

func NewRemoteSnapshotFromGeneric(
	name string,
    genericSnapshot resource.ClusterSnapshot,
) RemoteSnapshot {
    
    issuedCertificateSet := certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet()
    podBounceDirectiveSet := certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet()
    
    xdsConfigSet := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()
    
    destinationRuleSet := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
    envoyFilterSet := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
    gatewaySet := networking_istio_io_v1alpha3_sets.NewGatewaySet()
    serviceEntrySet := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
    virtualServiceSet := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
    
    authorizationPolicySet := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	issuedCertificateSet := certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet()
	podBounceDirectiveSet := certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet()

	xdsConfigSet := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()

	destinationRuleSet := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	envoyFilterSet := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	gatewaySet := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	serviceEntrySet := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	virtualServiceSet := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
	sidecarSet := networking_istio_io_v1alpha3_sets.NewSidecarSet()

	authorizationPolicySet := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	for _, snapshot := range genericSnapshot {
    
    
    issuedCertificates := snapshot[schema.GroupVersionKind{
        Group: "certificates.mesh.gloo.solo.io",
        Version: "v1",
        Kind: "IssuedCertificate",
    }]

    for _, issuedCertificate := range issuedCertificates {
        issuedCertificateSet.Insert(issuedCertificate.(*certificates_mesh_gloo_solo_io_v1_types.IssuedCertificate))
    }
    podBounceDirectives := snapshot[schema.GroupVersionKind{
        Group: "certificates.mesh.gloo.solo.io",
        Version: "v1",
        Kind: "PodBounceDirective",
    }]

    for _, podBounceDirective := range podBounceDirectives {
        podBounceDirectiveSet.Insert(podBounceDirective.(*certificates_mesh_gloo_solo_io_v1_types.PodBounceDirective))
    }
    
    
    xdsConfigs := snapshot[schema.GroupVersionKind{
        Group: "xds.agent.enterprise.mesh.gloo.solo.io",
        Version: "v1beta1",
        Kind: "XdsConfig",
    }]

    for _, xdsConfig := range xdsConfigs {
        xdsConfigSet.Insert(xdsConfig.(*xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_types.XdsConfig))
    }
    
    
    destinationRules := snapshot[schema.GroupVersionKind{
        Group: "networking.istio.io",
        Version: "v1alpha3",
        Kind: "DestinationRule",
    }]

    for _, destinationRule := range destinationRules {
        destinationRuleSet.Insert(destinationRule.(*networking_istio_io_v1alpha3_types.DestinationRule))
    }
    envoyFilters := snapshot[schema.GroupVersionKind{
        Group: "networking.istio.io",
        Version: "v1alpha3",
        Kind: "EnvoyFilter",
    }]

    for _, envoyFilter := range envoyFilters {
        envoyFilterSet.Insert(envoyFilter.(*networking_istio_io_v1alpha3_types.EnvoyFilter))
    }
    gateways := snapshot[schema.GroupVersionKind{
        Group: "networking.istio.io",
        Version: "v1alpha3",
        Kind: "Gateway",
    }]

    for _, gateway := range gateways {
        gatewaySet.Insert(gateway.(*networking_istio_io_v1alpha3_types.Gateway))
    }
    serviceEntries := snapshot[schema.GroupVersionKind{
        Group: "networking.istio.io",
        Version: "v1alpha3",
        Kind: "ServiceEntry",
    }]

    for _, serviceEntry := range serviceEntries {
        serviceEntrySet.Insert(serviceEntry.(*networking_istio_io_v1alpha3_types.ServiceEntry))
    }
    virtualServices := snapshot[schema.GroupVersionKind{
        Group: "networking.istio.io",
        Version: "v1alpha3",
        Kind: "VirtualService",
    }]

    for _, virtualService := range virtualServices {
        virtualServiceSet.Insert(virtualService.(*networking_istio_io_v1alpha3_types.VirtualService))
    }
    
    
    authorizationPolicies := snapshot[schema.GroupVersionKind{
        Group: "security.istio.io",
        Version: "v1beta1",
        Kind: "AuthorizationPolicy",
    }]

    for _, authorizationPolicy := range authorizationPolicies {
        authorizationPolicySet.Insert(authorizationPolicy.(*security_istio_io_v1beta1_types.AuthorizationPolicy))
    }

    }
    return NewRemoteSnapshot(
    	name,
    issuedCertificateSet,
    podBounceDirectiveSet,
    xdsConfigSet,
    destinationRuleSet,
    envoyFilterSet,
    gatewaySet,
    serviceEntrySet,
    virtualServiceSet,
    authorizationPolicySet,
    )
}

		issuedCertificates := snapshot[schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "IssuedCertificate",
		}]

		for _, issuedCertificate := range issuedCertificates {
			issuedCertificateSet.Insert(issuedCertificate.(*certificates_mesh_gloo_solo_io_v1_types.IssuedCertificate))
		}
		podBounceDirectives := snapshot[schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1",
			Kind:    "PodBounceDirective",
		}]

		for _, podBounceDirective := range podBounceDirectives {
			podBounceDirectiveSet.Insert(podBounceDirective.(*certificates_mesh_gloo_solo_io_v1_types.PodBounceDirective))
		}

		xdsConfigs := snapshot[schema.GroupVersionKind{
			Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
			Version: "v1beta1",
			Kind:    "XdsConfig",
		}]

		for _, xdsConfig := range xdsConfigs {
			xdsConfigSet.Insert(xdsConfig.(*xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_types.XdsConfig))
		}

		destinationRules := snapshot[schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}]

		for _, destinationRule := range destinationRules {
			destinationRuleSet.Insert(destinationRule.(*networking_istio_io_v1alpha3_types.DestinationRule))
		}
		envoyFilters := snapshot[schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}]

		for _, envoyFilter := range envoyFilters {
			envoyFilterSet.Insert(envoyFilter.(*networking_istio_io_v1alpha3_types.EnvoyFilter))
		}
		gateways := snapshot[schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}]

		for _, gateway := range gateways {
			gatewaySet.Insert(gateway.(*networking_istio_io_v1alpha3_types.Gateway))
		}
		serviceEntries := snapshot[schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}]

		for _, serviceEntry := range serviceEntries {
			serviceEntrySet.Insert(serviceEntry.(*networking_istio_io_v1alpha3_types.ServiceEntry))
		}
		virtualServices := snapshot[schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}]

		for _, virtualService := range virtualServices {
			virtualServiceSet.Insert(virtualService.(*networking_istio_io_v1alpha3_types.VirtualService))
		}
		sidecars := snapshot[schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Sidecar",
		}]

		for _, sidecar := range sidecars {
			sidecarSet.Insert(sidecar.(*networking_istio_io_v1alpha3_types.Sidecar))
		}

		authorizationPolicies := snapshot[schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}]


	}
	return NewRemoteSnapshot(
		name,
		issuedCertificateSet,
		podBounceDirectiveSet,
		xdsConfigSet,
		destinationRuleSet,
		envoyFilterSet,
		gatewaySet,
		serviceEntrySet,
		virtualServiceSet,
		sidecarSet,
		authorizationPolicySet,
	)
}

func (s snapshotRemote) IssuedCertificates() certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet {
    return s.issuedCertificates
}

func (s snapshotRemote) PodBounceDirectives() certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet {
    return s.podBounceDirectives
}


func (s snapshotRemote) XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet {
    return s.xdsConfigs
}


func (s snapshotRemote) DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
    return s.destinationRules
}

func (s snapshotRemote) EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
    return s.envoyFilters
}

func (s snapshotRemote) Gateways() networking_istio_io_v1alpha3_sets.GatewaySet {
    return s.gateways
}

func (s snapshotRemote) ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
    return s.serviceEntries
}

func (s snapshotRemote) VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
    return s.virtualServices
}

func (s snapshotRemote) Sidecars() networking_istio_io_v1alpha3_sets.SidecarSet {
	return s.sidecars
}

func (s snapshotRemote) AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
    return s.authorizationPolicies
}

func (s snapshotRemote) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts RemoteSyncStatusOptions) error {
	var errs error
    
    
    if opts.IssuedCertificate {
        for _, obj := range s.IssuedCertificates().List() {
            clusterClient, err := mcClient.Cluster(obj.ClusterName)
            if err != nil {
                errs = multierror.Append(errs, err)
                continue
            }
            if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
                errs = multierror.Append(errs, err)
            }
        }
    }
    if opts.PodBounceDirective {
        for _, obj := range s.PodBounceDirectives().List() {
            clusterClient, err := mcClient.Cluster(obj.ClusterName)
            if err != nil {
                errs = multierror.Append(errs, err)
                continue
            }
            if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
                errs = multierror.Append(errs, err)
            }
        }
    }
    
    if opts.XdsConfig {
        for _, obj := range s.XdsConfigs().List() {
            clusterClient, err := mcClient.Cluster(obj.ClusterName)
            if err != nil {
                errs = multierror.Append(errs, err)
                continue
            }
            if _, err := controllerutils.UpdateStatusImmutable(ctx, clusterClient, obj); err != nil {
                errs = multierror.Append(errs, err)
            }
        }
    }
    
    
    return errs
}


func (s snapshotRemote) SyncStatuses(ctx context.Context, c client.Client, opts RemoteSyncStatusOptions) error {
    var errs error
    
    
    if opts.IssuedCertificate {
        for _, obj := range s.IssuedCertificates().List() {
            if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
                errs = multierror.Append(errs, err)
            }
        }
    }
    if opts.PodBounceDirective {
        for _, obj := range s.PodBounceDirectives().List() {
            if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
                errs = multierror.Append(errs, err)
            }
        }
    }
    
    if opts.XdsConfig {
        for _, obj := range s.XdsConfigs().List() {
            if _, err := controllerutils.UpdateStatusImmutable(ctx, c, obj); err != nil {
                errs = multierror.Append(errs, err)
            }
        }
    }
    
    
    return errs
}

func (s snapshotRemote) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["issuedCertificates"] = s.issuedCertificates.List()
	snapshotMap["podBounceDirectives"] = s.podBounceDirectives.List()
	snapshotMap["xdsConfigs"] = s.xdsConfigs.List()
	snapshotMap["destinationRules"] = s.destinationRules.List()
	snapshotMap["envoyFilters"] = s.envoyFilters.List()
	snapshotMap["gateways"] = s.gateways.List()
	snapshotMap["serviceEntries"] = s.serviceEntries.List()
	snapshotMap["virtualServices"] = s.virtualServices.List()
	snapshotMap["sidecars"] = s.sidecars.List()
	snapshotMap["authorizationPolicies"] = s.authorizationPolicies.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
type RemoteBuilder interface {
    BuildSnapshot(ctx context.Context, name string, opts RemoteBuildOptions) (RemoteSnapshot, error)
}

// Options for building a snapshot
type RemoteBuildOptions struct {

	// List options for composing a snapshot from IssuedCertificates
	IssuedCertificates ResourceRemoteBuildOptions
	// List options for composing a snapshot from PodBounceDirectives
	PodBounceDirectives ResourceRemoteBuildOptions

	// List options for composing a snapshot from XdsConfigs
	XdsConfigs ResourceRemoteBuildOptions

	// List options for composing a snapshot from DestinationRules
	DestinationRules ResourceRemoteBuildOptions
	// List options for composing a snapshot from EnvoyFilters
	EnvoyFilters ResourceRemoteBuildOptions
	// List options for composing a snapshot from Gateways
	Gateways ResourceRemoteBuildOptions
	// List options for composing a snapshot from ServiceEntries
	ServiceEntries ResourceRemoteBuildOptions
	// List options for composing a snapshot from VirtualServices
	VirtualServices ResourceRemoteBuildOptions
	// List options for composing a snapshot from Sidecars
	Sidecars ResourceRemoteBuildOptions

	// List options for composing a snapshot from AuthorizationPolicies
	AuthorizationPolicies ResourceRemoteBuildOptions
}

// Options for reading resources of a given type
type ResourceRemoteBuildOptions struct {

    // List options for composing a snapshot from a resource type
    ListOptions []client.ListOption

    // If provided, ensure the resource has been verified before adding it to snapshots
    Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterRemoteBuilder struct {
    clusters multicluster.Interface
    client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterRemoteBuilder(
        clusters multicluster.Interface,
        client multicluster.Client,
) RemoteBuilder {
    return &multiClusterRemoteBuilder{
        clusters: clusters,
        client:   client,
    }
}

func (b *multiClusterRemoteBuilder) BuildSnapshot(ctx context.Context, name string, opts RemoteBuildOptions) (RemoteSnapshot, error) {

	issuedCertificates := certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet()
	podBounceDirectives := certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet()

	xdsConfigs := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()

	destinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	envoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	serviceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	virtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
	sidecars := networking_istio_io_v1alpha3_sets.NewSidecarSet()

	authorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertIssuedCertificatesFromCluster(ctx, cluster, issuedCertificates, opts.IssuedCertificates); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertPodBounceDirectivesFromCluster(ctx, cluster, podBounceDirectives, opts.PodBounceDirectives); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertXdsConfigsFromCluster(ctx, cluster, xdsConfigs, opts.XdsConfigs); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDestinationRulesFromCluster(ctx, cluster, destinationRules, opts.DestinationRules); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertEnvoyFiltersFromCluster(ctx, cluster, envoyFilters, opts.EnvoyFilters); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertGatewaysFromCluster(ctx, cluster, gateways, opts.Gateways); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertServiceEntriesFromCluster(ctx, cluster, serviceEntries, opts.ServiceEntries); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualServicesFromCluster(ctx, cluster, virtualServices, opts.VirtualServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertSidecarsFromCluster(ctx, cluster, sidecars, opts.Sidecars); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAuthorizationPoliciesFromCluster(ctx, cluster, authorizationPolicies, opts.AuthorizationPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewRemoteSnapshot(
		name,

		issuedCertificates,
		podBounceDirectives,
		xdsConfigs,
		destinationRules,
		envoyFilters,
		gateways,
		serviceEntries,
		virtualServices,
		sidecars,
		authorizationPolicies,
	)

	return outputSnap, errs
}

		if err := b.insertIssuedCertificatesFromCluster(ctx, cluster, issuedCertificates, opts.IssuedCertificates); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertPodBounceDirectivesFromCluster(ctx, cluster, podBounceDirectives, opts.PodBounceDirectives); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertXdsConfigsFromCluster(ctx, cluster, xdsConfigs, opts.XdsConfigs); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDestinationRulesFromCluster(ctx, cluster, destinationRules, opts.DestinationRules); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertEnvoyFiltersFromCluster(ctx, cluster, envoyFilters, opts.EnvoyFilters); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertGatewaysFromCluster(ctx, cluster, gateways, opts.Gateways); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertServiceEntriesFromCluster(ctx, cluster, serviceEntries, opts.ServiceEntries); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertVirtualServicesFromCluster(ctx, cluster, virtualServices, opts.VirtualServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertAuthorizationPoliciesFromCluster(ctx, cluster, authorizationPolicies, opts.AuthorizationPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewRemoteSnapshot(
		name,

		issuedCertificates,
		podBounceDirectives,
		xdsConfigs,
		destinationRules,
		envoyFilters,
		gateways,
		serviceEntries,
		virtualServices,
		authorizationPolicies,
	)

	return outputSnap, errs
}




func (b *multiClusterRemoteBuilder) insertIssuedCertificatesFromCluster(ctx context.Context, cluster string, issuedCertificates certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet, opts ResourceRemoteBuildOptions) error {
    issuedCertificateClient, err := certificates_mesh_gloo_solo_io_v1.NewMulticlusterIssuedCertificateClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "certificates.mesh.gloo.solo.io",
            Version: "v1",
            Kind:    "IssuedCertificate",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    issuedCertificateList, err := issuedCertificateClient.ListIssuedCertificate(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range issuedCertificateList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        issuedCertificates.Insert(item)
    }

    return nil
}
func (b *multiClusterRemoteBuilder) insertPodBounceDirectivesFromCluster(ctx context.Context, cluster string, podBounceDirectives certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet, opts ResourceRemoteBuildOptions) error {
    podBounceDirectiveClient, err := certificates_mesh_gloo_solo_io_v1.NewMulticlusterPodBounceDirectiveClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "certificates.mesh.gloo.solo.io",
            Version: "v1",
            Kind:    "PodBounceDirective",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    podBounceDirectiveList, err := podBounceDirectiveClient.ListPodBounceDirective(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range podBounceDirectiveList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        podBounceDirectives.Insert(item)
    }

    return nil
}


func (b *multiClusterRemoteBuilder) insertXdsConfigsFromCluster(ctx context.Context, cluster string, xdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet, opts ResourceRemoteBuildOptions) error {
    xdsConfigClient, err := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1.NewMulticlusterXdsConfigClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
            Version: "v1beta1",
            Kind:    "XdsConfig",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    xdsConfigList, err := xdsConfigClient.ListXdsConfig(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range xdsConfigList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        xdsConfigs.Insert(item)
    }

    return nil
}


func (b *multiClusterRemoteBuilder) insertDestinationRulesFromCluster(ctx context.Context, cluster string, destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet, opts ResourceRemoteBuildOptions) error {
    destinationRuleClient, err := networking_istio_io_v1alpha3.NewMulticlusterDestinationRuleClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "DestinationRule",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    destinationRuleList, err := destinationRuleClient.ListDestinationRule(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range destinationRuleList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        destinationRules.Insert(item)
    }

    return nil
}
func (b *multiClusterRemoteBuilder) insertEnvoyFiltersFromCluster(ctx context.Context, cluster string, envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet, opts ResourceRemoteBuildOptions) error {
    envoyFilterClient, err := networking_istio_io_v1alpha3.NewMulticlusterEnvoyFilterClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "EnvoyFilter",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    envoyFilterList, err := envoyFilterClient.ListEnvoyFilter(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range envoyFilterList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        envoyFilters.Insert(item)
    }

    return nil
}
func (b *multiClusterRemoteBuilder) insertGatewaysFromCluster(ctx context.Context, cluster string, gateways networking_istio_io_v1alpha3_sets.GatewaySet, opts ResourceRemoteBuildOptions) error {
    gatewayClient, err := networking_istio_io_v1alpha3.NewMulticlusterGatewayClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "Gateway",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    gatewayList, err := gatewayClient.ListGateway(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range gatewayList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        gateways.Insert(item)
    }

    return nil
}
func (b *multiClusterRemoteBuilder) insertServiceEntriesFromCluster(ctx context.Context, cluster string, serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet, opts ResourceRemoteBuildOptions) error {
    serviceEntryClient, err := networking_istio_io_v1alpha3.NewMulticlusterServiceEntryClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "ServiceEntry",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    serviceEntryList, err := serviceEntryClient.ListServiceEntry(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range serviceEntryList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        serviceEntries.Insert(item)
    }

    return nil
}
func (b *multiClusterRemoteBuilder) insertVirtualServicesFromCluster(ctx context.Context, cluster string, virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet, opts ResourceRemoteBuildOptions) error {
    virtualServiceClient, err := networking_istio_io_v1alpha3.NewMulticlusterVirtualServiceClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "VirtualService",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    virtualServiceList, err := virtualServiceClient.ListVirtualService(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range virtualServiceList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        virtualServices.Insert(item)
    }

    return nil
}
func (b *multiClusterRemoteBuilder) insertSidecarsFromCluster(ctx context.Context, cluster string, sidecars networking_istio_io_v1alpha3_sets.SidecarSet, opts ResourceRemoteBuildOptions) error {
	sidecarClient, err := networking_istio_io_v1alpha3.NewMulticlusterSidecarClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Sidecar",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	sidecarList, err := sidecarClient.ListSidecar(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range sidecarList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		sidecars.Insert(item)
	}

	return nil
}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualServiceList, err := virtualServiceClient.ListVirtualService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualServiceList.Items {
		item := item.DeepCopy()    // pike + own
		item.ClusterName = cluster // set cluster for in-memory processing
		virtualServices.Insert(item)
	}

	return nil
}


func (b *multiClusterRemoteBuilder) insertAuthorizationPoliciesFromCluster(ctx context.Context, cluster string, authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet, opts ResourceRemoteBuildOptions) error {
    authorizationPolicyClient, err := security_istio_io_v1beta1.NewMulticlusterAuthorizationPolicyClient(b.client).Cluster(cluster)
    if err != nil {
        return err
    }

    if opts.Verifier != nil {
    	mgr, err := b.clusters.Cluster(cluster)
    	if err != nil {
    		return err
        }

        gvk := schema.GroupVersionKind{
            Group:   "security.istio.io",
            Version: "v1beta1",
            Kind:    "AuthorizationPolicy",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
        	cluster,
        	mgr.GetConfig(),
        	gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    authorizationPolicyList, err := authorizationPolicyClient.ListAuthorizationPolicy(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range authorizationPolicyList.Items {
        item := item.DeepCopy()             // pike + own
        item.ClusterName = cluster // set cluster for in-memory processing
        authorizationPolicies.Insert(item)
    }

    return nil
}


// build a snapshot from resources in a single cluster
type singleClusterRemoteBuilder struct {
    mgr manager.Manager
    clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterRemoteBuilder(
        mgr manager.Manager,
) RemoteBuilder {
    return NewSingleClusterRemoteBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterRemoteBuilderWithClusterName(
        mgr manager.Manager,
        clusterName string,
) RemoteBuilder {
    return &singleClusterRemoteBuilder{
        mgr: mgr,
        clusterName: clusterName,
    }
}


	destinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	envoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	serviceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	virtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
	sidecars := networking_istio_io_v1alpha3_sets.NewSidecarSet()

	authorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	var errs error

	if err := b.insertIssuedCertificates(ctx, issuedCertificates, opts.IssuedCertificates); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertPodBounceDirectives(ctx, podBounceDirectives, opts.PodBounceDirectives); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertXdsConfigs(ctx, xdsConfigs, opts.XdsConfigs); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDestinationRules(ctx, destinationRules, opts.DestinationRules); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertEnvoyFilters(ctx, envoyFilters, opts.EnvoyFilters); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertGateways(ctx, gateways, opts.Gateways); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertServiceEntries(ctx, serviceEntries, opts.ServiceEntries); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertVirtualServices(ctx, virtualServices, opts.VirtualServices); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertSidecars(ctx, sidecars, opts.Sidecars); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertAuthorizationPolicies(ctx, authorizationPolicies, opts.AuthorizationPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewRemoteSnapshot(
		name,

		issuedCertificates,
		podBounceDirectives,
		xdsConfigs,
		destinationRules,
		envoyFilters,
		gateways,
		serviceEntries,
		virtualServices,
		sidecars,
		authorizationPolicies,
	)

	xdsConfigs := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()

func (b *singleClusterRemoteBuilder) BuildSnapshot(ctx context.Context, name string, opts RemoteBuildOptions) (RemoteSnapshot, error) {


    issuedCertificates := certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet()
    podBounceDirectives := certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet()

    xdsConfigs := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()

    destinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
    envoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
    gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
    serviceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
    virtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()

    authorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

    var errs error


    if err := b.insertIssuedCertificates(ctx,  issuedCertificates, opts.IssuedCertificates); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertPodBounceDirectives(ctx,  podBounceDirectives, opts.PodBounceDirectives); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertXdsConfigs(ctx,  xdsConfigs, opts.XdsConfigs); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertDestinationRules(ctx,  destinationRules, opts.DestinationRules); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertEnvoyFilters(ctx,  envoyFilters, opts.EnvoyFilters); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertGateways(ctx,  gateways, opts.Gateways); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertServiceEntries(ctx,  serviceEntries, opts.ServiceEntries); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertVirtualServices(ctx,  virtualServices, opts.VirtualServices); err != nil {
        errs = multierror.Append(errs, err)
    }
    if err := b.insertAuthorizationPolicies(ctx,  authorizationPolicies, opts.AuthorizationPolicies); err != nil {
        errs = multierror.Append(errs, err)
    }

    outputSnap := NewRemoteSnapshot(
        name,

        issuedCertificates,
        podBounceDirectives,
        xdsConfigs,
        destinationRules,
        envoyFilters,
        gateways,
        serviceEntries,
        virtualServices,
        authorizationPolicies,
    )

    return outputSnap, errs
}




func (b *singleClusterRemoteBuilder) insertIssuedCertificates(ctx context.Context, issuedCertificates certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "certificates.mesh.gloo.solo.io",
            Version: "v1",
            Kind:    "IssuedCertificate",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    issuedCertificateList, err := certificates_mesh_gloo_solo_io_v1.NewIssuedCertificateClient(b.mgr.GetClient()).ListIssuedCertificate(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range issuedCertificateList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        issuedCertificates.Insert(item)
    }

    return nil
}
func (b *singleClusterRemoteBuilder) insertPodBounceDirectives(ctx context.Context, podBounceDirectives certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "certificates.mesh.gloo.solo.io",
            Version: "v1",
            Kind:    "PodBounceDirective",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    podBounceDirectiveList, err := certificates_mesh_gloo_solo_io_v1.NewPodBounceDirectiveClient(b.mgr.GetClient()).ListPodBounceDirective(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range podBounceDirectiveList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        podBounceDirectives.Insert(item)
    }

    return nil
}


func (b *singleClusterRemoteBuilder) insertXdsConfigs(ctx context.Context, xdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
            Version: "v1beta1",
            Kind:    "XdsConfig",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    xdsConfigList, err := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1.NewXdsConfigClient(b.mgr.GetClient()).ListXdsConfig(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range xdsConfigList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        xdsConfigs.Insert(item)
    }

    return nil
}


func (b *singleClusterRemoteBuilder) insertDestinationRules(ctx context.Context, destinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "DestinationRule",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    destinationRuleList, err := networking_istio_io_v1alpha3.NewDestinationRuleClient(b.mgr.GetClient()).ListDestinationRule(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range destinationRuleList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        destinationRules.Insert(item)
    }

    return nil
}
func (b *singleClusterRemoteBuilder) insertEnvoyFilters(ctx context.Context, envoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "EnvoyFilter",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    envoyFilterList, err := networking_istio_io_v1alpha3.NewEnvoyFilterClient(b.mgr.GetClient()).ListEnvoyFilter(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range envoyFilterList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        envoyFilters.Insert(item)
    }

    return nil
}
func (b *singleClusterRemoteBuilder) insertGateways(ctx context.Context, gateways networking_istio_io_v1alpha3_sets.GatewaySet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "Gateway",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    gatewayList, err := networking_istio_io_v1alpha3.NewGatewayClient(b.mgr.GetClient()).ListGateway(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range gatewayList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        gateways.Insert(item)
    }

    return nil
}
func (b *singleClusterRemoteBuilder) insertServiceEntries(ctx context.Context, serviceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "ServiceEntry",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    serviceEntryList, err := networking_istio_io_v1alpha3.NewServiceEntryClient(b.mgr.GetClient()).ListServiceEntry(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range serviceEntryList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        serviceEntries.Insert(item)
    }

    return nil
}
func (b *singleClusterRemoteBuilder) insertVirtualServices(ctx context.Context, virtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "networking.istio.io",
            Version: "v1alpha3",
            Kind:    "VirtualService",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    virtualServiceList, err := networking_istio_io_v1alpha3.NewVirtualServiceClient(b.mgr.GetClient()).ListVirtualService(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range virtualServiceList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        virtualServices.Insert(item)
    }

    return nil
}
func (b *singleClusterRemoteBuilder) insertSidecars(ctx context.Context, sidecars networking_istio_io_v1alpha3_sets.SidecarSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Sidecar",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	sidecarList, err := networking_istio_io_v1alpha3.NewSidecarClient(b.mgr.GetClient()).ListSidecar(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range sidecarList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		sidecars.Insert(item)
	}

	return nil
}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	virtualServiceList, err := networking_istio_io_v1alpha3.NewVirtualServiceClient(b.mgr.GetClient()).ListVirtualService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range virtualServiceList.Items {
		item := item.DeepCopy() // pike + own the item.
		item.ClusterName = b.clusterName
		virtualServices.Insert(item)
	}

	return nil
}


func (b *singleClusterRemoteBuilder) insertAuthorizationPolicies(ctx context.Context, authorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet, opts ResourceRemoteBuildOptions) error {

    if opts.Verifier != nil {
        gvk := schema.GroupVersionKind{
            Group:   "security.istio.io",
            Version: "v1beta1",
            Kind:    "AuthorizationPolicy",
        }

        if resourceRegistered, err := opts.Verifier.VerifyServerResource(
            "", // verify in the local cluster
            b.mgr.GetConfig(),
            gvk,
        ); err != nil{
            return err
        } else if !resourceRegistered {
            return nil
        }
    }

    authorizationPolicyList, err := security_istio_io_v1beta1.NewAuthorizationPolicyClient(b.mgr.GetClient()).ListAuthorizationPolicy(ctx, opts.ListOptions...)
    if err != nil {
        return err
    }

    for _, item := range authorizationPolicyList.Items {
        item := item.DeepCopy()               // pike + own the item.
        item.ClusterName = b.clusterName
        authorizationPolicies.Insert(item)
    }

    return nil
}


// build a snapshot from resources in a single cluster
type inMemoryRemoteBuilder struct {
    getSnapshot func() (resource.ClusterSnapshot, error)
}

// Produces snapshots of resources read from the manager for the given cluster
func NewInMemoryRemoteBuilder(
        getSnapshot func() (resource.ClusterSnapshot, error),
) RemoteBuilder {
    return &inMemoryRemoteBuilder{
        getSnapshot: getSnapshot,
    }
}

func (i *inMemoryRemoteBuilder) BuildSnapshot(ctx context.Context, name string, opts RemoteBuildOptions) (RemoteSnapshot, error) {
	genericSnap, err := i.getSnapshot()
	if err != nil {
		return nil, err
	}

	issuedCertificates := certificates_mesh_gloo_solo_io_v1_sets.NewIssuedCertificateSet()
	podBounceDirectives := certificates_mesh_gloo_solo_io_v1_sets.NewPodBounceDirectiveSet()

	xdsConfigs := xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.NewXdsConfigSet()

	destinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	envoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	serviceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	virtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
	sidecars := networking_istio_io_v1alpha3_sets.NewSidecarSet()

	authorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	genericSnap.ForEachObject(func(cluster string, gvk schema.GroupVersionKind, obj resource.TypedObject) {
		switch obj := obj.(type) {
		// insert IssuedCertificates
		case *certificates_mesh_gloo_solo_io_v1_types.IssuedCertificate:
			i.insertIssuedCertificate(ctx, obj, issuedCertificates, opts)
		// insert PodBounceDirectives
		case *certificates_mesh_gloo_solo_io_v1_types.PodBounceDirective:
			i.insertPodBounceDirective(ctx, obj, podBounceDirectives, opts)
		// insert XdsConfigs
		case *xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_types.XdsConfig:
			i.insertXdsConfig(ctx, obj, xdsConfigs, opts)
		// insert DestinationRules
		case *networking_istio_io_v1alpha3_types.DestinationRule:
			i.insertDestinationRule(ctx, obj, destinationRules, opts)
		// insert EnvoyFilters
		case *networking_istio_io_v1alpha3_types.EnvoyFilter:
			i.insertEnvoyFilter(ctx, obj, envoyFilters, opts)
		// insert Gateways
		case *networking_istio_io_v1alpha3_types.Gateway:
			i.insertGateway(ctx, obj, gateways, opts)
		// insert ServiceEntries
		case *networking_istio_io_v1alpha3_types.ServiceEntry:
			i.insertServiceEntry(ctx, obj, serviceEntries, opts)
		// insert VirtualServices
		case *networking_istio_io_v1alpha3_types.VirtualService:
			i.insertVirtualService(ctx, obj, virtualServices, opts)
		// insert Sidecars
		case *networking_istio_io_v1alpha3_types.Sidecar:
			i.insertSidecar(ctx, obj, sidecars, opts)
		// insert AuthorizationPolicies
		case *security_istio_io_v1beta1_types.AuthorizationPolicy:
			i.insertAuthorizationPolicy(ctx, obj, authorizationPolicies, opts)
		}
	})

	return NewRemoteSnapshot(
		name,

		issuedCertificates,
		podBounceDirectives,
		xdsConfigs,
		destinationRules,
		envoyFilters,
		gateways,
		serviceEntries,
		virtualServices,
		sidecars,
		authorizationPolicies,
	), nil
}

func (i *inMemoryRemoteBuilder) insertIssuedCertificate(
	ctx context.Context,
	issuedCertificate *certificates_mesh_gloo_solo_io_v1_types.IssuedCertificate,
	issuedCertificateSet certificates_mesh_gloo_solo_io_v1_sets.IssuedCertificateSet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.IssuedCertificates.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = issuedCertificate.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(issuedCertificate.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		issuedCertificateSet.Insert(issuedCertificate)
	}
}
func (i *inMemoryRemoteBuilder) insertPodBounceDirective(
	ctx context.Context,
	podBounceDirective *certificates_mesh_gloo_solo_io_v1_types.PodBounceDirective,
	podBounceDirectiveSet certificates_mesh_gloo_solo_io_v1_sets.PodBounceDirectiveSet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.PodBounceDirectives.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = podBounceDirective.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(podBounceDirective.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		podBounceDirectiveSet.Insert(podBounceDirective)
	}
}

func (i *inMemoryRemoteBuilder) insertXdsConfig(
	ctx context.Context,
	xdsConfig *xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_types.XdsConfig,
	xdsConfigSet xds_agent_enterprise_mesh_gloo_solo_io_v1beta1_sets.XdsConfigSet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.XdsConfigs.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = xdsConfig.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(xdsConfig.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		xdsConfigSet.Insert(xdsConfig)
	}
}

func (i *inMemoryRemoteBuilder) insertDestinationRule(
	ctx context.Context,
	destinationRule *networking_istio_io_v1alpha3_types.DestinationRule,
	destinationRuleSet networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.DestinationRules.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = destinationRule.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(destinationRule.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		destinationRuleSet.Insert(destinationRule)
	}
}
func (i *inMemoryRemoteBuilder) insertEnvoyFilter(
	ctx context.Context,
	envoyFilter *networking_istio_io_v1alpha3_types.EnvoyFilter,
	envoyFilterSet networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.EnvoyFilters.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = envoyFilter.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(envoyFilter.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		envoyFilterSet.Insert(envoyFilter)
	}
}
func (i *inMemoryRemoteBuilder) insertGateway(
	ctx context.Context,
	gateway *networking_istio_io_v1alpha3_types.Gateway,
	gatewaySet networking_istio_io_v1alpha3_sets.GatewaySet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.Gateways.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = gateway.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(gateway.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		gatewaySet.Insert(gateway)
	}
}
func (i *inMemoryRemoteBuilder) insertServiceEntry(
	ctx context.Context,
	serviceEntry *networking_istio_io_v1alpha3_types.ServiceEntry,
	serviceEntrySet networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.ServiceEntries.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = serviceEntry.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(serviceEntry.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		serviceEntrySet.Insert(serviceEntry)
	}
}
func (i *inMemoryRemoteBuilder) insertVirtualService(
	ctx context.Context,
	virtualService *networking_istio_io_v1alpha3_types.VirtualService,
	virtualServiceSet networking_istio_io_v1alpha3_sets.VirtualServiceSet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.VirtualServices.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = virtualService.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(virtualService.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		virtualServiceSet.Insert(virtualService)
	}
}
func (i *inMemoryRemoteBuilder) insertSidecar(
	ctx context.Context,
	sidecar *networking_istio_io_v1alpha3_types.Sidecar,
	sidecarSet networking_istio_io_v1alpha3_sets.SidecarSet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.Sidecars.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = sidecar.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(sidecar.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		sidecarSet.Insert(sidecar)
	}
}

func (i *inMemoryRemoteBuilder) insertAuthorizationPolicy(
	ctx context.Context,
	authorizationPolicy *security_istio_io_v1beta1_types.AuthorizationPolicy,
	authorizationPolicySet security_istio_io_v1beta1_sets.AuthorizationPolicySet,
	buildOpts RemoteBuildOptions,
) {

	opts := buildOpts.AuthorizationPolicies.ListOptions

	listOpts := &client.ListOptions{}
	for _, opt := range opts {
		opt.ApplyToList(listOpts)
	}

	filteredOut := false
	if listOpts.Namespace != "" {
		filteredOut = authorizationPolicy.Namespace != listOpts.Namespace
	}
	if listOpts.LabelSelector != nil {
		filteredOut = !listOpts.LabelSelector.Matches(labels.Set(authorizationPolicy.Labels))
	}
	if listOpts.FieldSelector != nil {
		contextutils.LoggerFrom(ctx).DPanicf("field selector is not implemented for in-memory remote snapshot")
	}

	if !filteredOut {
		authorizationPolicySet.Insert(authorizationPolicy)
	}
}
