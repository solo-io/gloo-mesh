// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/supergloo/api/v1/routing.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	math "math"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	v1 "github.com/solo-io/gloo/projects/gloo/pkg/api/v1"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
	v1alpha3 "github.com/solo-io/supergloo/pkg/api/external/istio/networking/v1alpha3"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// types of delays available, currently only fixed is supported
type FaultInjection_Delay_Type int32

const (
	FaultInjection_Delay_FIXED FaultInjection_Delay_Type = 0
)

var FaultInjection_Delay_Type_name = map[int32]string{
	0: "FIXED",
}

var FaultInjection_Delay_Type_value = map[string]int32{
	"FIXED": 0,
}

func (x FaultInjection_Delay_Type) String() string {
	return proto.EnumName(FaultInjection_Delay_Type_name, int32(x))
}

func (FaultInjection_Delay_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{5, 0, 0}
}

// a routing rule applies some L7 routing features to an existing mesh
// routing rules specify the following:
// for all requests:
// - originating from from **source pods**
// - sent to **destination pods**
// - matching one or more **request matcher**
// apply the specified RoutingRuleSpec
type RoutingRule struct {
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by supergloo during validation
	Status core.Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status"`
	// Metadata contains the object metadata for this resource
	Metadata core.Metadata `protobuf:"bytes,101,opt,name=metadata,proto3" json:"metadata"`
	// target where we apply this rule. this can be a mesh group or an individual mesh
	TargetMesh *core.ResourceRef `protobuf:"bytes,1,opt,name=target_mesh,json=targetMesh,proto3" json:"target_mesh,omitempty"`
	// requests originating from these pods will have the rule applied
	// leave empty to have all pods in the mesh apply these rules
	//
	// > Note: Source Selectors are ignored when RoutingRules are
	// applied to pods in a Linkerd mesh. RoutingRules will apply to
	// all selected destinations in Linkerd, regardless of the source.
	SourceSelector *PodSelector `protobuf:"bytes,2,opt,name=source_selector,json=sourceSelector,proto3" json:"source_selector,omitempty"`
	// requests destined for these pods will have the rule applied
	// leave empty to apply to all destination pods in the mesh
	DestinationSelector *PodSelector `protobuf:"bytes,3,opt,name=destination_selector,json=destinationSelector,proto3" json:"destination_selector,omitempty"`
	// if specified, this rule will only apply to http requests
	// in the mesh matching these parameters
	// note that Linkerd only supports matching on Request Path and Method
	RequestMatchers []*v1.Matcher `protobuf:"bytes,4,rep,name=request_matchers,json=requestMatchers,proto3" json:"request_matchers,omitempty"`
	// contains the configuration that will be applied to
	// selected pods within the target mesh(es)
	Spec                 *RoutingRuleSpec `protobuf:"bytes,5,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RoutingRule) Reset()         { *m = RoutingRule{} }
func (m *RoutingRule) String() string { return proto.CompactTextString(m) }
func (*RoutingRule) ProtoMessage()    {}
func (*RoutingRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{0}
}
func (m *RoutingRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoutingRule.Unmarshal(m, b)
}
func (m *RoutingRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoutingRule.Marshal(b, m, deterministic)
}
func (m *RoutingRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoutingRule.Merge(m, src)
}
func (m *RoutingRule) XXX_Size() int {
	return xxx_messageInfo_RoutingRule.Size(m)
}
func (m *RoutingRule) XXX_DiscardUnknown() {
	xxx_messageInfo_RoutingRule.DiscardUnknown(m)
}

var xxx_messageInfo_RoutingRule proto.InternalMessageInfo

func (m *RoutingRule) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *RoutingRule) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

func (m *RoutingRule) GetTargetMesh() *core.ResourceRef {
	if m != nil {
		return m.TargetMesh
	}
	return nil
}

func (m *RoutingRule) GetSourceSelector() *PodSelector {
	if m != nil {
		return m.SourceSelector
	}
	return nil
}

func (m *RoutingRule) GetDestinationSelector() *PodSelector {
	if m != nil {
		return m.DestinationSelector
	}
	return nil
}

func (m *RoutingRule) GetRequestMatchers() []*v1.Matcher {
	if m != nil {
		return m.RequestMatchers
	}
	return nil
}

func (m *RoutingRule) GetSpec() *RoutingRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// the routing configuration that will be applied to the mesh(es)
type RoutingRuleSpec struct {
	// a routing rule can have one of several types
	// Note: types imported from istio will be replaced with our own
	// simpler types, this is just a place to start from
	//
	// Types that are valid to be assigned to RuleType:
	//	*RoutingRuleSpec_TrafficShifting
	//	*RoutingRuleSpec_FaultInjection
	//	*RoutingRuleSpec_RequestTimeout
	//	*RoutingRuleSpec_Retries
	//	*RoutingRuleSpec_CorsPolicy
	//	*RoutingRuleSpec_Mirror
	//	*RoutingRuleSpec_HeaderManipulation
	RuleType             isRoutingRuleSpec_RuleType `protobuf_oneof:"rule_type"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *RoutingRuleSpec) Reset()         { *m = RoutingRuleSpec{} }
func (m *RoutingRuleSpec) String() string { return proto.CompactTextString(m) }
func (*RoutingRuleSpec) ProtoMessage()    {}
func (*RoutingRuleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{1}
}
func (m *RoutingRuleSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoutingRuleSpec.Unmarshal(m, b)
}
func (m *RoutingRuleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoutingRuleSpec.Marshal(b, m, deterministic)
}
func (m *RoutingRuleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoutingRuleSpec.Merge(m, src)
}
func (m *RoutingRuleSpec) XXX_Size() int {
	return xxx_messageInfo_RoutingRuleSpec.Size(m)
}
func (m *RoutingRuleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RoutingRuleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RoutingRuleSpec proto.InternalMessageInfo

type isRoutingRuleSpec_RuleType interface {
	isRoutingRuleSpec_RuleType()
	Equal(interface{}) bool
}

type RoutingRuleSpec_TrafficShifting struct {
	TrafficShifting *TrafficShifting `protobuf:"bytes,1,opt,name=traffic_shifting,json=trafficShifting,proto3,oneof"`
}
type RoutingRuleSpec_FaultInjection struct {
	FaultInjection *FaultInjection `protobuf:"bytes,2,opt,name=fault_injection,json=faultInjection,proto3,oneof"`
}
type RoutingRuleSpec_RequestTimeout struct {
	RequestTimeout *time.Duration `protobuf:"bytes,7,opt,name=request_timeout,json=requestTimeout,proto3,oneof,stdduration"`
}
type RoutingRuleSpec_Retries struct {
	Retries *RetryPolicy `protobuf:"bytes,8,opt,name=retries,proto3,oneof"`
}
type RoutingRuleSpec_CorsPolicy struct {
	CorsPolicy *v1alpha3.CorsPolicy `protobuf:"bytes,10,opt,name=cors_policy,json=corsPolicy,proto3,oneof"`
}
type RoutingRuleSpec_Mirror struct {
	Mirror *v1.Destination `protobuf:"bytes,9,opt,name=mirror,proto3,oneof"`
}
type RoutingRuleSpec_HeaderManipulation struct {
	HeaderManipulation *HeaderManipulation `protobuf:"bytes,12,opt,name=header_manipulation,json=headerManipulation,proto3,oneof"`
}

func (*RoutingRuleSpec_TrafficShifting) isRoutingRuleSpec_RuleType()    {}
func (*RoutingRuleSpec_FaultInjection) isRoutingRuleSpec_RuleType()     {}
func (*RoutingRuleSpec_RequestTimeout) isRoutingRuleSpec_RuleType()     {}
func (*RoutingRuleSpec_Retries) isRoutingRuleSpec_RuleType()            {}
func (*RoutingRuleSpec_CorsPolicy) isRoutingRuleSpec_RuleType()         {}
func (*RoutingRuleSpec_Mirror) isRoutingRuleSpec_RuleType()             {}
func (*RoutingRuleSpec_HeaderManipulation) isRoutingRuleSpec_RuleType() {}

func (m *RoutingRuleSpec) GetRuleType() isRoutingRuleSpec_RuleType {
	if m != nil {
		return m.RuleType
	}
	return nil
}

func (m *RoutingRuleSpec) GetTrafficShifting() *TrafficShifting {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_TrafficShifting); ok {
		return x.TrafficShifting
	}
	return nil
}

func (m *RoutingRuleSpec) GetFaultInjection() *FaultInjection {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_FaultInjection); ok {
		return x.FaultInjection
	}
	return nil
}

func (m *RoutingRuleSpec) GetRequestTimeout() *time.Duration {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_RequestTimeout); ok {
		return x.RequestTimeout
	}
	return nil
}

func (m *RoutingRuleSpec) GetRetries() *RetryPolicy {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_Retries); ok {
		return x.Retries
	}
	return nil
}

func (m *RoutingRuleSpec) GetCorsPolicy() *v1alpha3.CorsPolicy {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_CorsPolicy); ok {
		return x.CorsPolicy
	}
	return nil
}

func (m *RoutingRuleSpec) GetMirror() *v1.Destination {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_Mirror); ok {
		return x.Mirror
	}
	return nil
}

func (m *RoutingRuleSpec) GetHeaderManipulation() *HeaderManipulation {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_HeaderManipulation); ok {
		return x.HeaderManipulation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RoutingRuleSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RoutingRuleSpec_OneofMarshaler, _RoutingRuleSpec_OneofUnmarshaler, _RoutingRuleSpec_OneofSizer, []interface{}{
		(*RoutingRuleSpec_TrafficShifting)(nil),
		(*RoutingRuleSpec_FaultInjection)(nil),
		(*RoutingRuleSpec_RequestTimeout)(nil),
		(*RoutingRuleSpec_Retries)(nil),
		(*RoutingRuleSpec_CorsPolicy)(nil),
		(*RoutingRuleSpec_Mirror)(nil),
		(*RoutingRuleSpec_HeaderManipulation)(nil),
	}
}

func _RoutingRuleSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RoutingRuleSpec)
	// rule_type
	switch x := m.RuleType.(type) {
	case *RoutingRuleSpec_TrafficShifting:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TrafficShifting); err != nil {
			return err
		}
	case *RoutingRuleSpec_FaultInjection:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FaultInjection); err != nil {
			return err
		}
	case *RoutingRuleSpec_RequestTimeout:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		dAtA, err := github_com_gogo_protobuf_types.StdDurationMarshal(*x.RequestTimeout)
		if err != nil {
			return err
		}
		if err := b.EncodeRawBytes(dAtA); err != nil {
			return err
		}
	case *RoutingRuleSpec_Retries:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Retries); err != nil {
			return err
		}
	case *RoutingRuleSpec_CorsPolicy:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CorsPolicy); err != nil {
			return err
		}
	case *RoutingRuleSpec_Mirror:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mirror); err != nil {
			return err
		}
	case *RoutingRuleSpec_HeaderManipulation:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HeaderManipulation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RoutingRuleSpec.RuleType has unexpected type %T", x)
	}
	return nil
}

func _RoutingRuleSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RoutingRuleSpec)
	switch tag {
	case 1: // rule_type.traffic_shifting
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TrafficShifting)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_TrafficShifting{msg}
		return true, err
	case 2: // rule_type.fault_injection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FaultInjection)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_FaultInjection{msg}
		return true, err
	case 7: // rule_type.request_timeout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		if err != nil {
			return true, err
		}
		c := new(time.Duration)
		if err2 := github_com_gogo_protobuf_types.StdDurationUnmarshal(c, x); err2 != nil {
			return true, err
		}
		m.RuleType = &RoutingRuleSpec_RequestTimeout{c}
		return true, err
	case 8: // rule_type.retries
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RetryPolicy)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_Retries{msg}
		return true, err
	case 10: // rule_type.cors_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(v1alpha3.CorsPolicy)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_CorsPolicy{msg}
		return true, err
	case 9: // rule_type.mirror
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(v1.Destination)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_Mirror{msg}
		return true, err
	case 12: // rule_type.header_manipulation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HeaderManipulation)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_HeaderManipulation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RoutingRuleSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RoutingRuleSpec)
	// rule_type
	switch x := m.RuleType.(type) {
	case *RoutingRuleSpec_TrafficShifting:
		s := proto.Size(x.TrafficShifting)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_FaultInjection:
		s := proto.Size(x.FaultInjection)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_RequestTimeout:
		s := github_com_gogo_protobuf_types.SizeOfStdDuration(*x.RequestTimeout)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_Retries:
		s := proto.Size(x.Retries)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_CorsPolicy:
		s := proto.Size(x.CorsPolicy)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_Mirror:
		s := proto.Size(x.Mirror)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_HeaderManipulation:
		s := proto.Size(x.HeaderManipulation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RetryPolicy contains mesh-specific retry configuration
// Different meshes support different Retry features
// SuperGloo's RetryPolicy exposes config for multiple meshes simultaneously,
// Allowing the same RoutingRule to apply retries to different mesh types
// The configuration applied to the target mesh will use the corresponding
// config for each type, while other config types will be ignored
type RetryPolicy struct {
	// retry each failed request until success or max number of retries met
	// this retry policy will be applied to any targeted Istio Mesh Instances
	MaxRetries *v1alpha3.HTTPRetry `protobuf:"bytes,1,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
	// allocate a 'retry budget' for each mesh sidecar
	// once the proxy reaches its retry budget limit, it will
	// stop retrying all requests for the given retry window.
	// this can be used to prevent cascading failures when
	// outages cause bursts of retries.
	// this retry policy will be applied to any targeted Linkerd Mesh Instances
	RetryBudget          *RetryBudget `protobuf:"bytes,2,opt,name=retry_budget,json=retryBudget,proto3" json:"retry_budget,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RetryPolicy) Reset()         { *m = RetryPolicy{} }
func (m *RetryPolicy) String() string { return proto.CompactTextString(m) }
func (*RetryPolicy) ProtoMessage()    {}
func (*RetryPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{2}
}
func (m *RetryPolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RetryPolicy.Unmarshal(m, b)
}
func (m *RetryPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RetryPolicy.Marshal(b, m, deterministic)
}
func (m *RetryPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicy.Merge(m, src)
}
func (m *RetryPolicy) XXX_Size() int {
	return xxx_messageInfo_RetryPolicy.Size(m)
}
func (m *RetryPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicy proto.InternalMessageInfo

func (m *RetryPolicy) GetMaxRetries() *v1alpha3.HTTPRetry {
	if m != nil {
		return m.MaxRetries
	}
	return nil
}

func (m *RetryPolicy) GetRetryBudget() *RetryBudget {
	if m != nil {
		return m.RetryBudget
	}
	return nil
}

// RetryBudget describes the maximum number of retries that should be issued to
// the destination services. Can only be applied to Linkerd meshes
type RetryBudget struct {
	// The ratio of additional traffic that may be added by retries.  A
	// retry_ratio of 0.1 means that 1 retry may be attempted for every 10 regular
	// requests.  A retry_ratio of 1.0 means that 1 retry may be attempted for
	// every 1 regular request (in other words, total request load may be doubled
	// as a result of retries).
	RetryRatio float32 `protobuf:"fixed32,1,opt,name=retry_ratio,json=retryRatio,proto3" json:"retry_ratio,omitempty"`
	// The proxy may always attempt this number of retries per second, even if it
	// would violate the retryRatio.  This is to allow retries to happen even
	// when the request rate is very low.
	MinRetriesPerSecond uint32 `protobuf:"varint,2,opt,name=min_retries_per_second,json=minRetriesPerSecond,proto3" json:"min_retries_per_second,omitempty"`
	// This duration indicates for how long requests should be considered for the
	// purposes of enforcing the retryRatio.  A higher value considers a larger
	// window and therefore allows burstier retries.
	Ttl                  time.Duration `protobuf:"bytes,3,opt,name=ttl,proto3,stdduration" json:"ttl"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RetryBudget) Reset()         { *m = RetryBudget{} }
func (m *RetryBudget) String() string { return proto.CompactTextString(m) }
func (*RetryBudget) ProtoMessage()    {}
func (*RetryBudget) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{3}
}
func (m *RetryBudget) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RetryBudget.Unmarshal(m, b)
}
func (m *RetryBudget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RetryBudget.Marshal(b, m, deterministic)
}
func (m *RetryBudget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryBudget.Merge(m, src)
}
func (m *RetryBudget) XXX_Size() int {
	return xxx_messageInfo_RetryBudget.Size(m)
}
func (m *RetryBudget) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryBudget.DiscardUnknown(m)
}

var xxx_messageInfo_RetryBudget proto.InternalMessageInfo

func (m *RetryBudget) GetRetryRatio() float32 {
	if m != nil {
		return m.RetryRatio
	}
	return 0
}

func (m *RetryBudget) GetMinRetriesPerSecond() uint32 {
	if m != nil {
		return m.MinRetriesPerSecond
	}
	return 0
}

func (m *RetryBudget) GetTtl() time.Duration {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// requests for this rule will be routed to these destinations
type TrafficShifting struct {
	// split traffic between these subsets based on their weights
	// weights are relative to the sum of the weights
	Destinations         *v1.MultiDestination `protobuf:"bytes,1,opt,name=destinations,proto3" json:"destinations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TrafficShifting) Reset()         { *m = TrafficShifting{} }
func (m *TrafficShifting) String() string { return proto.CompactTextString(m) }
func (*TrafficShifting) ProtoMessage()    {}
func (*TrafficShifting) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{4}
}
func (m *TrafficShifting) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficShifting.Unmarshal(m, b)
}
func (m *TrafficShifting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficShifting.Marshal(b, m, deterministic)
}
func (m *TrafficShifting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficShifting.Merge(m, src)
}
func (m *TrafficShifting) XXX_Size() int {
	return xxx_messageInfo_TrafficShifting.Size(m)
}
func (m *TrafficShifting) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficShifting.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficShifting proto.InternalMessageInfo

func (m *TrafficShifting) GetDestinations() *v1.MultiDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

// FaultInjection can be used to specify one or more faults to inject
// while forwarding http requests to the destination specified in a route.
// Faults include aborting the Http request from downstream service, and/or delaying
// proxying of requests. A fault rule MUST HAVE delay or abort.
type FaultInjection struct {
	// Types that are valid to be assigned to FaultInjectionType:
	//	*FaultInjection_Delay_
	//	*FaultInjection_Abort_
	FaultInjectionType isFaultInjection_FaultInjectionType `protobuf_oneof:"fault_injection_type"`
	// Percentage of requests to be faulted with the error code provided.
	// Values range between 0 and 100
	Percentage           float64  `protobuf:"fixed64,5,opt,name=percentage,proto3" json:"percentage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FaultInjection) Reset()         { *m = FaultInjection{} }
func (m *FaultInjection) String() string { return proto.CompactTextString(m) }
func (*FaultInjection) ProtoMessage()    {}
func (*FaultInjection) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{5}
}
func (m *FaultInjection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FaultInjection.Unmarshal(m, b)
}
func (m *FaultInjection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FaultInjection.Marshal(b, m, deterministic)
}
func (m *FaultInjection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FaultInjection.Merge(m, src)
}
func (m *FaultInjection) XXX_Size() int {
	return xxx_messageInfo_FaultInjection.Size(m)
}
func (m *FaultInjection) XXX_DiscardUnknown() {
	xxx_messageInfo_FaultInjection.DiscardUnknown(m)
}

var xxx_messageInfo_FaultInjection proto.InternalMessageInfo

type isFaultInjection_FaultInjectionType interface {
	isFaultInjection_FaultInjectionType()
	Equal(interface{}) bool
}

type FaultInjection_Delay_ struct {
	Delay *FaultInjection_Delay `protobuf:"bytes,1,opt,name=delay,proto3,oneof"`
}
type FaultInjection_Abort_ struct {
	Abort *FaultInjection_Abort `protobuf:"bytes,2,opt,name=abort,proto3,oneof"`
}

func (*FaultInjection_Delay_) isFaultInjection_FaultInjectionType() {}
func (*FaultInjection_Abort_) isFaultInjection_FaultInjectionType() {}

func (m *FaultInjection) GetFaultInjectionType() isFaultInjection_FaultInjectionType {
	if m != nil {
		return m.FaultInjectionType
	}
	return nil
}

func (m *FaultInjection) GetDelay() *FaultInjection_Delay {
	if x, ok := m.GetFaultInjectionType().(*FaultInjection_Delay_); ok {
		return x.Delay
	}
	return nil
}

func (m *FaultInjection) GetAbort() *FaultInjection_Abort {
	if x, ok := m.GetFaultInjectionType().(*FaultInjection_Abort_); ok {
		return x.Abort
	}
	return nil
}

func (m *FaultInjection) GetPercentage() float64 {
	if m != nil {
		return m.Percentage
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FaultInjection) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FaultInjection_OneofMarshaler, _FaultInjection_OneofUnmarshaler, _FaultInjection_OneofSizer, []interface{}{
		(*FaultInjection_Delay_)(nil),
		(*FaultInjection_Abort_)(nil),
	}
}

func _FaultInjection_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FaultInjection)
	// fault_injection_type
	switch x := m.FaultInjectionType.(type) {
	case *FaultInjection_Delay_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Delay); err != nil {
			return err
		}
	case *FaultInjection_Abort_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Abort); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FaultInjection.FaultInjectionType has unexpected type %T", x)
	}
	return nil
}

func _FaultInjection_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FaultInjection)
	switch tag {
	case 1: // fault_injection_type.delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FaultInjection_Delay)
		err := b.DecodeMessage(msg)
		m.FaultInjectionType = &FaultInjection_Delay_{msg}
		return true, err
	case 2: // fault_injection_type.abort
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FaultInjection_Abort)
		err := b.DecodeMessage(msg)
		m.FaultInjectionType = &FaultInjection_Abort_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FaultInjection_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FaultInjection)
	// fault_injection_type
	switch x := m.FaultInjectionType.(type) {
	case *FaultInjection_Delay_:
		s := proto.Size(x.Delay)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FaultInjection_Abort_:
		s := proto.Size(x.Abort)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The _fixedDelay_ field is used to indicate the amount of delay in seconds.
// The optional _percentage_ field can be used to only delay a certain
// percentage of requests. If left unspecified, all request will be delayed.
type FaultInjection_Delay struct {
	// duration of delay, matches golang duration spec
	Duration time.Duration `protobuf:"bytes,3,opt,name=duration,proto3,stdduration" json:"duration"`
	// type of delay based on the enum below
	DelayType            FaultInjection_Delay_Type `protobuf:"varint,6,opt,name=delay_type,json=delayType,proto3,enum=supergloo.solo.io.FaultInjection_Delay_Type" json:"delay_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *FaultInjection_Delay) Reset()         { *m = FaultInjection_Delay{} }
func (m *FaultInjection_Delay) String() string { return proto.CompactTextString(m) }
func (*FaultInjection_Delay) ProtoMessage()    {}
func (*FaultInjection_Delay) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{5, 0}
}
func (m *FaultInjection_Delay) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FaultInjection_Delay.Unmarshal(m, b)
}
func (m *FaultInjection_Delay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FaultInjection_Delay.Marshal(b, m, deterministic)
}
func (m *FaultInjection_Delay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FaultInjection_Delay.Merge(m, src)
}
func (m *FaultInjection_Delay) XXX_Size() int {
	return xxx_messageInfo_FaultInjection_Delay.Size(m)
}
func (m *FaultInjection_Delay) XXX_DiscardUnknown() {
	xxx_messageInfo_FaultInjection_Delay.DiscardUnknown(m)
}

var xxx_messageInfo_FaultInjection_Delay proto.InternalMessageInfo

func (m *FaultInjection_Delay) GetDuration() time.Duration {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *FaultInjection_Delay) GetDelayType() FaultInjection_Delay_Type {
	if m != nil {
		return m.DelayType
	}
	return FaultInjection_Delay_FIXED
}

// The _httpStatus_ field is used to indicate the HTTP status code to
// return to the caller. The optional _percentage_ field can be used to only
// abort a certain percentage of requests. If not specified, all requests are
// aborted.
type FaultInjection_Abort struct {
	// Types that are valid to be assigned to ErrorType:
	//	*FaultInjection_Abort_HttpStatus
	ErrorType            isFaultInjection_Abort_ErrorType `protobuf_oneof:"error_type"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *FaultInjection_Abort) Reset()         { *m = FaultInjection_Abort{} }
func (m *FaultInjection_Abort) String() string { return proto.CompactTextString(m) }
func (*FaultInjection_Abort) ProtoMessage()    {}
func (*FaultInjection_Abort) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{5, 1}
}
func (m *FaultInjection_Abort) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FaultInjection_Abort.Unmarshal(m, b)
}
func (m *FaultInjection_Abort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FaultInjection_Abort.Marshal(b, m, deterministic)
}
func (m *FaultInjection_Abort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FaultInjection_Abort.Merge(m, src)
}
func (m *FaultInjection_Abort) XXX_Size() int {
	return xxx_messageInfo_FaultInjection_Abort.Size(m)
}
func (m *FaultInjection_Abort) XXX_DiscardUnknown() {
	xxx_messageInfo_FaultInjection_Abort.DiscardUnknown(m)
}

var xxx_messageInfo_FaultInjection_Abort proto.InternalMessageInfo

type isFaultInjection_Abort_ErrorType interface {
	isFaultInjection_Abort_ErrorType()
	Equal(interface{}) bool
}

type FaultInjection_Abort_HttpStatus struct {
	HttpStatus int32 `protobuf:"varint,4,opt,name=http_status,json=httpStatus,proto3,oneof"`
}

func (*FaultInjection_Abort_HttpStatus) isFaultInjection_Abort_ErrorType() {}

func (m *FaultInjection_Abort) GetErrorType() isFaultInjection_Abort_ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return nil
}

func (m *FaultInjection_Abort) GetHttpStatus() int32 {
	if x, ok := m.GetErrorType().(*FaultInjection_Abort_HttpStatus); ok {
		return x.HttpStatus
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FaultInjection_Abort) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FaultInjection_Abort_OneofMarshaler, _FaultInjection_Abort_OneofUnmarshaler, _FaultInjection_Abort_OneofSizer, []interface{}{
		(*FaultInjection_Abort_HttpStatus)(nil),
	}
}

func _FaultInjection_Abort_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *FaultInjection_Abort_HttpStatus:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		return fmt.Errorf("FaultInjection_Abort.ErrorType has unexpected type %T", x)
	}
	return nil
}

func _FaultInjection_Abort_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FaultInjection_Abort)
	switch tag {
	case 4: // error_type.http_status
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ErrorType = &FaultInjection_Abort_HttpStatus{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _FaultInjection_Abort_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *FaultInjection_Abort_HttpStatus:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// manipulate request and response headers
type HeaderManipulation struct {
	// HTTP headers to remove before returning a response to the caller.
	RemoveResponseHeaders []string `protobuf:"bytes,12,rep,name=remove_response_headers,json=removeResponseHeaders,proto3" json:"remove_response_headers,omitempty"`
	// Additional HTTP headers to add before returning a response to the
	// caller.
	AppendResponseHeaders map[string]string `protobuf:"bytes,13,rep,name=append_response_headers,json=appendResponseHeaders,proto3" json:"append_response_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// HTTP headers to remove before forwarding a request to the
	// destination service.
	RemoveRequestHeaders []string `protobuf:"bytes,14,rep,name=remove_request_headers,json=removeRequestHeaders,proto3" json:"remove_request_headers,omitempty"`
	// Additional HTTP headers to add before forwarding a request to the
	// destination service.
	AppendRequestHeaders map[string]string `protobuf:"bytes,15,rep,name=append_request_headers,json=appendRequestHeaders,proto3" json:"append_request_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HeaderManipulation) Reset()         { *m = HeaderManipulation{} }
func (m *HeaderManipulation) String() string { return proto.CompactTextString(m) }
func (*HeaderManipulation) ProtoMessage()    {}
func (*HeaderManipulation) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{6}
}
func (m *HeaderManipulation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeaderManipulation.Unmarshal(m, b)
}
func (m *HeaderManipulation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeaderManipulation.Marshal(b, m, deterministic)
}
func (m *HeaderManipulation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderManipulation.Merge(m, src)
}
func (m *HeaderManipulation) XXX_Size() int {
	return xxx_messageInfo_HeaderManipulation.Size(m)
}
func (m *HeaderManipulation) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderManipulation.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderManipulation proto.InternalMessageInfo

func (m *HeaderManipulation) GetRemoveResponseHeaders() []string {
	if m != nil {
		return m.RemoveResponseHeaders
	}
	return nil
}

func (m *HeaderManipulation) GetAppendResponseHeaders() map[string]string {
	if m != nil {
		return m.AppendResponseHeaders
	}
	return nil
}

func (m *HeaderManipulation) GetRemoveRequestHeaders() []string {
	if m != nil {
		return m.RemoveRequestHeaders
	}
	return nil
}

func (m *HeaderManipulation) GetAppendRequestHeaders() map[string]string {
	if m != nil {
		return m.AppendRequestHeaders
	}
	return nil
}

func init() {
	proto.RegisterEnum("supergloo.solo.io.FaultInjection_Delay_Type", FaultInjection_Delay_Type_name, FaultInjection_Delay_Type_value)
	proto.RegisterType((*RoutingRule)(nil), "supergloo.solo.io.RoutingRule")
	proto.RegisterType((*RoutingRuleSpec)(nil), "supergloo.solo.io.RoutingRuleSpec")
	proto.RegisterType((*RetryPolicy)(nil), "supergloo.solo.io.RetryPolicy")
	proto.RegisterType((*RetryBudget)(nil), "supergloo.solo.io.RetryBudget")
	proto.RegisterType((*TrafficShifting)(nil), "supergloo.solo.io.TrafficShifting")
	proto.RegisterType((*FaultInjection)(nil), "supergloo.solo.io.FaultInjection")
	proto.RegisterType((*FaultInjection_Delay)(nil), "supergloo.solo.io.FaultInjection.Delay")
	proto.RegisterType((*FaultInjection_Abort)(nil), "supergloo.solo.io.FaultInjection.Abort")
	proto.RegisterType((*HeaderManipulation)(nil), "supergloo.solo.io.HeaderManipulation")
	proto.RegisterMapType((map[string]string)(nil), "supergloo.solo.io.HeaderManipulation.AppendRequestHeadersEntry")
	proto.RegisterMapType((map[string]string)(nil), "supergloo.solo.io.HeaderManipulation.AppendResponseHeadersEntry")
}

func init() {
	proto.RegisterFile("github.com/solo-io/supergloo/api/v1/routing.proto", fileDescriptor_29316bfaa5f4ba1a)
}

var fileDescriptor_29316bfaa5f4ba1a = []byte{
	// 1168 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x41, 0x73, 0x1b, 0x35,
	0x14, 0xb6, 0x63, 0x3b, 0x8d, 0x9f, 0xd3, 0x38, 0x55, 0xdd, 0x74, 0xeb, 0x43, 0x9a, 0x7a, 0x60,
	0x9a, 0x43, 0xbb, 0x3b, 0x4d, 0xa0, 0x93, 0xc9, 0xa5, 0xad, 0x49, 0x5b, 0x17, 0xc8, 0x10, 0x94,
	0x30, 0xd3, 0xe1, 0xb2, 0xb3, 0x59, 0x3f, 0xdb, 0x22, 0xeb, 0xd5, 0x22, 0x69, 0x43, 0x7c, 0xed,
	0x81, 0xbf, 0x00, 0xc3, 0x81, 0x73, 0x6f, 0xfc, 0x0d, 0x7e, 0x05, 0xcc, 0x70, 0xe3, 0xd8, 0x7f,
	0xc0, 0x48, 0xab, 0x75, 0xec, 0xc4, 0x0d, 0xce, 0xc9, 0x2b, 0xbd, 0xef, 0x7b, 0xfa, 0x24, 0xbd,
	0xef, 0xc9, 0xf0, 0xa4, 0xcf, 0xd4, 0x20, 0x3d, 0x76, 0x43, 0x3e, 0xf4, 0x24, 0x8f, 0xf8, 0x63,
	0xc6, 0x3d, 0x99, 0x26, 0x28, 0xfa, 0x11, 0xe7, 0x5e, 0x90, 0x30, 0xef, 0xf4, 0x89, 0x27, 0x78,
	0xaa, 0x58, 0xdc, 0x77, 0x13, 0xc1, 0x15, 0x27, 0xb7, 0xc6, 0x71, 0x57, 0x33, 0x5c, 0xc6, 0x9b,
	0x8d, 0x3e, 0xef, 0x73, 0x13, 0xf5, 0xf4, 0x57, 0x06, 0x6c, 0xae, 0xf7, 0x39, 0xef, 0x47, 0xe8,
	0x99, 0xd1, 0x71, 0xda, 0xf3, 0xba, 0xa9, 0x08, 0x14, 0xe3, 0xb1, 0x8d, 0x6f, 0xcd, 0xb3, 0xb6,
	0xc4, 0x08, 0x43, 0xc5, 0x85, 0xe5, 0xec, 0xcc, 0xe0, 0x18, 0x78, 0x22, 0xf8, 0x0f, 0x18, 0x2a,
	0xe9, 0x4d, 0x92, 0x13, 0xc1, 0xcf, 0x46, 0x96, 0xe9, 0x31, 0xa9, 0x18, 0xf7, 0x62, 0x54, 0x3f,
	0x71, 0x71, 0xc2, 0xe2, 0xbe, 0x77, 0xfa, 0x24, 0x88, 0x92, 0x41, 0xb0, 0xed, 0x9d, 0x32, 0xa1,
	0xd2, 0x20, 0xf2, 0x25, 0x8a, 0x53, 0x16, 0xa2, 0x25, 0xcc, 0x3c, 0x1a, 0xfd, 0x7b, 0xc2, 0x54,
	0xbe, 0xc0, 0x10, 0x55, 0xd0, 0x0d, 0x54, 0x90, 0xaf, 0x31, 0x07, 0x45, 0xaa, 0x40, 0xa5, 0xd2,
	0x12, 0x1e, 0xcd, 0x41, 0x10, 0xd8, 0xbb, 0x86, 0xa2, 0x7c, 0x9c, 0x51, 0x5a, 0xff, 0x96, 0xa0,
	0x46, 0xb3, 0xeb, 0xa3, 0x69, 0x84, 0x64, 0x0b, 0x16, 0x33, 0x01, 0x4e, 0x77, 0xa3, 0xb8, 0x59,
	0xdb, 0x6a, 0xb8, 0x21, 0x17, 0x98, 0x5f, 0xa4, 0x7b, 0x68, 0x62, 0xed, 0xf2, 0x9f, 0x7f, 0xdd,
	0x2f, 0x50, 0x8b, 0x24, 0x3b, 0xb0, 0x94, 0xef, 0xd3, 0x41, 0xc3, 0x5a, 0x9b, 0x66, 0xed, 0xdb,
	0xa8, 0xe5, 0x8d, 0xd1, 0x64, 0x17, 0x6a, 0x2a, 0x10, 0x7d, 0x54, 0xfe, 0x10, 0xe5, 0xc0, 0x29,
	0x1a, 0xf2, 0xbd, 0x69, 0x32, 0x45, 0xc9, 0x53, 0x11, 0x22, 0xc5, 0x1e, 0x85, 0x0c, 0xbd, 0x8f,
	0x72, 0x40, 0x5e, 0x43, 0x3d, 0x0b, 0xf8, 0x79, 0x09, 0x38, 0x0b, 0x86, 0xbf, 0xee, 0x5e, 0x2a,
	0x40, 0xf7, 0x80, 0x77, 0x0f, 0x2d, 0x8a, 0xae, 0x64, 0xb4, 0x7c, 0x4c, 0xbe, 0x85, 0x46, 0x17,
	0xa5, 0x62, 0xb1, 0xa9, 0xbd, 0xf3, 0x6c, 0xa5, 0xb9, 0xb2, 0xdd, 0x9e, 0xe0, 0x8e, 0x53, 0x3e,
	0x87, 0x55, 0x81, 0x3f, 0xa6, 0x28, 0x95, 0x3f, 0x0c, 0x54, 0x38, 0x40, 0x21, 0x9d, 0xf2, 0x46,
	0x69, 0xb3, 0xb6, 0x75, 0xc7, 0x9d, 0xca, 0xb4, 0x9f, 0x45, 0x69, 0xdd, 0xc2, 0xed, 0x58, 0x92,
	0xa7, 0x50, 0x96, 0x09, 0x86, 0x4e, 0xc5, 0x88, 0x68, 0xcd, 0x10, 0x31, 0x71, 0x6b, 0x87, 0x09,
	0x86, 0xd4, 0xe0, 0x77, 0x9b, 0xef, 0x3e, 0x94, 0xcb, 0xb0, 0x20, 0xc4, 0xbb, 0x0f, 0xe5, 0x15,
	0xb2, 0x6c, 0x9d, 0x29, 0xd2, 0x08, 0x65, 0xeb, 0xf7, 0x32, 0xd4, 0x2f, 0xb0, 0xc8, 0x37, 0xb0,
	0xaa, 0x44, 0xd0, 0xeb, 0xb1, 0xd0, 0x97, 0x03, 0xd6, 0xd3, 0x31, 0x7b, 0x0d, 0xb3, 0xd6, 0x3c,
	0xca, 0xa0, 0x87, 0x16, 0xd9, 0x29, 0xd0, 0xba, 0x9a, 0x9e, 0x22, 0x5f, 0x43, 0xbd, 0x17, 0xa4,
	0x91, 0xf2, 0x59, 0xac, 0xfd, 0xc6, 0x78, 0x6c, 0xaf, 0xe5, 0xc1, 0x8c, 0x7c, 0xaf, 0x34, 0xf2,
	0x4d, 0x0e, 0xec, 0x14, 0xe8, 0x4a, 0x6f, 0x6a, 0x86, 0x7c, 0x09, 0xf9, 0xc9, 0xf8, 0x8a, 0x0d,
	0x91, 0xa7, 0xca, 0xb9, 0x61, 0x8b, 0x24, 0x6b, 0x1e, 0x6e, 0xde, 0x3c, 0xdc, 0x3d, 0xdb, 0x3c,
	0xda, 0xe5, 0x5f, 0xff, 0xbe, 0x5f, 0xd4, 0xb9, 0x2c, 0xf3, 0x28, 0x23, 0x92, 0x5d, 0xb8, 0x21,
	0x50, 0x09, 0x86, 0xd2, 0x59, 0xfa, 0xe8, 0xd5, 0x52, 0x54, 0x62, 0x74, 0xc0, 0x23, 0x16, 0x8e,
	0x3a, 0x05, 0x9a, 0x13, 0x48, 0x07, 0x6a, 0x21, 0x17, 0xd2, 0x4f, 0x4c, 0xc4, 0x01, 0xc3, 0xff,
	0xd4, 0x35, 0x2d, 0xc3, 0x3d, 0x6f, 0x19, 0x6e, 0xde, 0x32, 0xdc, 0x2f, 0xb8, 0x90, 0xe3, 0x34,
	0x10, 0x8e, 0x47, 0x64, 0x1b, 0x16, 0x87, 0x4c, 0x08, 0x2e, 0x9c, 0x6a, 0xbe, 0x91, 0xc9, 0xf5,
	0xf7, 0xce, 0xab, 0xa9, 0x53, 0xa0, 0x16, 0x4a, 0xde, 0xc2, 0xed, 0x01, 0x06, 0x5d, 0x14, 0xfe,
	0x30, 0x88, 0x59, 0x92, 0x46, 0x06, 0xe0, 0x2c, 0x5b, 0x19, 0x97, 0xb7, 0xd1, 0x31, 0xe8, 0xfd,
	0x09, 0x70, 0xa7, 0x40, 0xc9, 0xe0, 0xd2, 0x6c, 0xbb, 0x06, 0x55, 0x5d, 0x1c, 0xbe, 0x1a, 0x25,
	0xd8, 0xfa, 0xa5, 0x08, 0xb5, 0x89, 0x03, 0x20, 0x2f, 0xa1, 0x36, 0x0c, 0xce, 0xfc, 0xfc, 0xd4,
	0xb2, 0xba, 0xf8, 0xe4, 0x8a, 0x5d, 0x77, 0x8e, 0x8e, 0x0e, 0x4c, 0x02, 0x0a, 0xc3, 0xe0, 0x8c,
	0xda, 0xc3, 0x7b, 0x01, 0xcb, 0x3a, 0xc5, 0xc8, 0x3f, 0x4e, 0xbb, 0x7d, 0x54, 0x57, 0xd8, 0xd4,
	0x70, 0xdb, 0x06, 0x45, 0x6b, 0xe2, 0x7c, 0xd0, 0xfa, 0x2d, 0x57, 0x96, 0x8d, 0xc9, 0x7d, 0xc8,
	0xc2, 0xbe, 0xb9, 0x73, 0xa3, 0x6c, 0x81, 0x82, 0x99, 0xa2, 0x7a, 0x86, 0x6c, 0xc3, 0xda, 0x90,
	0xc5, 0xb9, 0x74, 0x3f, 0x41, 0xe1, 0x4b, 0x0c, 0x79, 0xdc, 0x35, 0xab, 0xdf, 0xa4, 0xb7, 0x87,
	0x2c, 0xb6, 0xfa, 0x0e, 0x50, 0x1c, 0x9a, 0x10, 0xf9, 0x1c, 0x4a, 0x4a, 0x45, 0xd6, 0xf8, 0x57,
	0x54, 0xd8, 0x92, 0x6e, 0x63, 0xba, 0xca, 0xa8, 0xc6, 0xb7, 0xbe, 0x83, 0xfa, 0x05, 0x63, 0x90,
	0x36, 0x2c, 0x4f, 0xf4, 0x85, 0xfc, 0xe8, 0xd6, 0x2f, 0x98, 0x3f, 0x8d, 0x14, 0x9b, 0xb8, 0x70,
	0x3a, 0xc5, 0x69, 0xfd, 0x51, 0x82, 0x95, 0x69, 0x83, 0x90, 0x67, 0x50, 0xe9, 0x62, 0x14, 0x8c,
	0x6c, 0xbe, 0x87, 0xff, 0x6b, 0x29, 0x77, 0x4f, 0xc3, 0x3b, 0x05, 0x9a, 0xf1, 0x74, 0x82, 0xe0,
	0x98, 0x8b, 0xfc, 0x0e, 0xe6, 0x48, 0xf0, 0x42, 0xc3, 0x75, 0x02, 0xc3, 0x23, 0xeb, 0x00, 0x09,
	0x8a, 0x10, 0x63, 0x15, 0xf4, 0xd1, 0x74, 0xa7, 0x22, 0x9d, 0x98, 0x69, 0xbe, 0x2f, 0x42, 0x65,
	0xcf, 0x2e, 0xb5, 0x94, 0xbf, 0xe7, 0xd7, 0x39, 0xd1, 0x31, 0x89, 0x7c, 0x05, 0x60, 0x44, 0x9b,
	0xda, 0x74, 0x16, 0x37, 0x8a, 0x9b, 0x2b, 0x5b, 0x8f, 0xe6, 0xdc, 0xb1, 0x7b, 0x34, 0x4a, 0x90,
	0x56, 0x0d, 0x5f, 0x7f, 0xb6, 0x6e, 0x41, 0x59, 0xff, 0x92, 0x2a, 0x54, 0x5e, 0xbd, 0x79, 0xfb,
	0x72, 0x6f, 0xb5, 0xd0, 0xdc, 0x81, 0x8a, 0xd9, 0x1c, 0x79, 0x00, 0xb5, 0x81, 0x52, 0x89, 0x6f,
	0x1f, 0xbe, 0xf2, 0x46, 0x71, 0xb3, 0xa2, 0x5d, 0xab, 0x27, 0xed, 0x83, 0xb7, 0x0c, 0x80, 0xda,
	0x89, 0x46, 0x4b, 0x7b, 0x0d, 0x1a, 0x17, 0x7a, 0x5c, 0xe6, 0x9f, 0x9f, 0xcb, 0x40, 0x2e, 0x3b,
	0x8f, 0x3c, 0x85, 0xbb, 0x02, 0x87, 0xfc, 0x14, 0x7d, 0x81, 0x32, 0xe1, 0xb1, 0x44, 0x3f, 0x73,
	0xa2, 0x74, 0x96, 0x37, 0x4a, 0x9b, 0x55, 0x7a, 0x27, 0x0b, 0x53, 0x1b, 0xcd, 0x52, 0x48, 0x72,
	0x06, 0x77, 0x83, 0x24, 0xc1, 0xb8, 0x7b, 0x99, 0x77, 0xd3, 0x3c, 0x26, 0xcf, 0xe7, 0x72, 0xbe,
	0xfb, 0xc2, 0x24, 0xb9, 0x90, 0xfd, 0x65, 0xac, 0xbd, 0x72, 0x27, 0x98, 0x15, 0x23, 0x9f, 0xc1,
	0xda, 0x58, 0x71, 0xd6, 0x7d, 0xf3, 0x85, 0x57, 0x8c, 0xe0, 0x46, 0x2e, 0xd8, 0x04, 0x73, 0x56,
	0x0a, 0x6b, 0x63, 0xbd, 0xd3, 0xac, 0xba, 0x91, 0xfb, 0xec, 0x7a, 0x72, 0x27, 0x73, 0x67, 0x6a,
	0x1b, 0xc1, 0x8c, 0x50, 0xb3, 0x03, 0xcd, 0x8f, 0xef, 0x90, 0xac, 0x42, 0xe9, 0x04, 0x33, 0xc3,
	0x54, 0xa9, 0xfe, 0x24, 0x0d, 0xa8, 0x9c, 0x06, 0x51, 0x8a, 0xc6, 0x03, 0x55, 0x9a, 0x0d, 0x76,
	0x17, 0x76, 0x8a, 0xcd, 0xd7, 0x70, 0xef, 0xa3, 0x8b, 0x5f, 0x27, 0x51, 0xfb, 0xf1, 0xfb, 0x7f,
	0xd6, 0x8b, 0xdf, 0x3f, 0xbc, 0xf2, 0xff, 0x6b, 0x72, 0xd2, 0xb7, 0xff, 0xc9, 0x8e, 0x17, 0x8d,
	0x21, 0xb6, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x79, 0xad, 0x40, 0xa4, 0x6d, 0x0b, 0x00, 0x00,
}

func (this *RoutingRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRule)
	if !ok {
		that2, ok := that.(RoutingRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if !this.TargetMesh.Equal(that1.TargetMesh) {
		return false
	}
	if !this.SourceSelector.Equal(that1.SourceSelector) {
		return false
	}
	if !this.DestinationSelector.Equal(that1.DestinationSelector) {
		return false
	}
	if len(this.RequestMatchers) != len(that1.RequestMatchers) {
		return false
	}
	for i := range this.RequestMatchers {
		if !this.RequestMatchers[i].Equal(that1.RequestMatchers[i]) {
			return false
		}
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec)
	if !ok {
		that2, ok := that.(RoutingRuleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RuleType == nil {
		if this.RuleType != nil {
			return false
		}
	} else if this.RuleType == nil {
		return false
	} else if !this.RuleType.Equal(that1.RuleType) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_TrafficShifting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_TrafficShifting)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_TrafficShifting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TrafficShifting.Equal(that1.TrafficShifting) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_FaultInjection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_FaultInjection)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_FaultInjection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FaultInjection.Equal(that1.FaultInjection) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_RequestTimeout) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_RequestTimeout)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_RequestTimeout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestTimeout != nil && that1.RequestTimeout != nil {
		if *this.RequestTimeout != *that1.RequestTimeout {
			return false
		}
	} else if this.RequestTimeout != nil {
		return false
	} else if that1.RequestTimeout != nil {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_Retries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_Retries)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_Retries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Retries.Equal(that1.Retries) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_CorsPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_CorsPolicy)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_CorsPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_Mirror) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_Mirror)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_Mirror)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Mirror.Equal(that1.Mirror) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_HeaderManipulation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_HeaderManipulation)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_HeaderManipulation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeaderManipulation.Equal(that1.HeaderManipulation) {
		return false
	}
	return true
}
func (this *RetryPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryPolicy)
	if !ok {
		that2, ok := that.(RetryPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MaxRetries.Equal(that1.MaxRetries) {
		return false
	}
	if !this.RetryBudget.Equal(that1.RetryBudget) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RetryBudget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryBudget)
	if !ok {
		that2, ok := that.(RetryBudget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RetryRatio != that1.RetryRatio {
		return false
	}
	if this.MinRetriesPerSecond != that1.MinRetriesPerSecond {
		return false
	}
	if this.Ttl != that1.Ttl {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TrafficShifting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrafficShifting)
	if !ok {
		that2, ok := that.(TrafficShifting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Destinations.Equal(that1.Destinations) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection)
	if !ok {
		that2, ok := that.(FaultInjection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.FaultInjectionType == nil {
		if this.FaultInjectionType != nil {
			return false
		}
	} else if this.FaultInjectionType == nil {
		return false
	} else if !this.FaultInjectionType.Equal(that1.FaultInjectionType) {
		return false
	}
	if this.Percentage != that1.Percentage {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection_Delay_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Delay_)
	if !ok {
		that2, ok := that.(FaultInjection_Delay_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Delay.Equal(that1.Delay) {
		return false
	}
	return true
}
func (this *FaultInjection_Abort_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Abort_)
	if !ok {
		that2, ok := that.(FaultInjection_Abort_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Abort.Equal(that1.Abort) {
		return false
	}
	return true
}
func (this *FaultInjection_Delay) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Delay)
	if !ok {
		that2, ok := that.(FaultInjection_Delay)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.DelayType != that1.DelayType {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection_Abort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Abort)
	if !ok {
		that2, ok := that.(FaultInjection_Abort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ErrorType == nil {
		if this.ErrorType != nil {
			return false
		}
	} else if this.ErrorType == nil {
		return false
	} else if !this.ErrorType.Equal(that1.ErrorType) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection_Abort_HttpStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Abort_HttpStatus)
	if !ok {
		that2, ok := that.(FaultInjection_Abort_HttpStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpStatus != that1.HttpStatus {
		return false
	}
	return true
}
func (this *HeaderManipulation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderManipulation)
	if !ok {
		that2, ok := that.(HeaderManipulation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RemoveResponseHeaders) != len(that1.RemoveResponseHeaders) {
		return false
	}
	for i := range this.RemoveResponseHeaders {
		if this.RemoveResponseHeaders[i] != that1.RemoveResponseHeaders[i] {
			return false
		}
	}
	if len(this.AppendResponseHeaders) != len(that1.AppendResponseHeaders) {
		return false
	}
	for i := range this.AppendResponseHeaders {
		if this.AppendResponseHeaders[i] != that1.AppendResponseHeaders[i] {
			return false
		}
	}
	if len(this.RemoveRequestHeaders) != len(that1.RemoveRequestHeaders) {
		return false
	}
	for i := range this.RemoveRequestHeaders {
		if this.RemoveRequestHeaders[i] != that1.RemoveRequestHeaders[i] {
			return false
		}
	}
	if len(this.AppendRequestHeaders) != len(that1.AppendRequestHeaders) {
		return false
	}
	for i := range this.AppendRequestHeaders {
		if this.AppendRequestHeaders[i] != that1.AppendRequestHeaders[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
