// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/supergloo/api/v1/routing.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	math "math"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	v1 "github.com/solo-io/gloo/projects/gloo/pkg/api/v1"
	core "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
	v1alpha3 "github.com/solo-io/supergloo/pkg/api/external/istio/networking/v1alpha3"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// a routing rule applies some L7 routing features to an existing mesh
// routing rules specify the following:
// for all requests:
// - originating from from **source pods**
// - sent to **destination pods**
// - matching one or more **request matcher**
// apply the specified RoutingRuleSpec
type RoutingRule struct {
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by supergloo during validation
	Status core.Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status"`
	// Metadata contains the object metadata for this resource
	Metadata core.Metadata `protobuf:"bytes,101,opt,name=metadata,proto3" json:"metadata"`
	// target where we apply this rule. this can be a mesh group or an individual mesh
	TargetMesh *core.ResourceRef `protobuf:"bytes,1,opt,name=target_mesh,json=targetMesh,proto3" json:"target_mesh,omitempty"`
	// requests originating from these pods will have the rule applied
	// leave empty to have all pods in the mesh apply these rules
	SourceSelector *PodSelector `protobuf:"bytes,2,opt,name=source_selector,json=sourceSelector,proto3" json:"source_selector,omitempty"`
	// requests destined for these pods will have the rule applied
	// leave empty to apply to all destination pods in the mesh
	DestinationSelector *PodSelector `protobuf:"bytes,3,opt,name=destination_selector,json=destinationSelector,proto3" json:"destination_selector,omitempty"`
	// if specified, this rule will only apply to http requests
	// in the mesh matching these parameters
	RequestMatchers []*v1.Matcher `protobuf:"bytes,4,rep,name=request_matchers,json=requestMatchers,proto3" json:"request_matchers,omitempty"`
	// contains the configuration that will be applied to
	// selected pods within the target mesh(es)
	Spec                 *RoutingRuleSpec `protobuf:"bytes,5,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RoutingRule) Reset()         { *m = RoutingRule{} }
func (m *RoutingRule) String() string { return proto.CompactTextString(m) }
func (*RoutingRule) ProtoMessage()    {}
func (*RoutingRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{0}
}
func (m *RoutingRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoutingRule.Unmarshal(m, b)
}
func (m *RoutingRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoutingRule.Marshal(b, m, deterministic)
}
func (m *RoutingRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoutingRule.Merge(m, src)
}
func (m *RoutingRule) XXX_Size() int {
	return xxx_messageInfo_RoutingRule.Size(m)
}
func (m *RoutingRule) XXX_DiscardUnknown() {
	xxx_messageInfo_RoutingRule.DiscardUnknown(m)
}

var xxx_messageInfo_RoutingRule proto.InternalMessageInfo

func (m *RoutingRule) GetStatus() core.Status {
	if m != nil {
		return m.Status
	}
	return core.Status{}
}

func (m *RoutingRule) GetMetadata() core.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core.Metadata{}
}

func (m *RoutingRule) GetTargetMesh() *core.ResourceRef {
	if m != nil {
		return m.TargetMesh
	}
	return nil
}

func (m *RoutingRule) GetSourceSelector() *PodSelector {
	if m != nil {
		return m.SourceSelector
	}
	return nil
}

func (m *RoutingRule) GetDestinationSelector() *PodSelector {
	if m != nil {
		return m.DestinationSelector
	}
	return nil
}

func (m *RoutingRule) GetRequestMatchers() []*v1.Matcher {
	if m != nil {
		return m.RequestMatchers
	}
	return nil
}

func (m *RoutingRule) GetSpec() *RoutingRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// the routing configuration that will be applied to the mesh(es)
type RoutingRuleSpec struct {
	// a routing rule can have one of several types
	// Note: types imported from istio will be replaced with our own
	// simpler types, this is just a place to start from
	//
	// Types that are valid to be assigned to RuleType:
	//	*RoutingRuleSpec_TrafficShifting
	//	*RoutingRuleSpec_FaultInjection
	//	*RoutingRuleSpec_RequestTimeout
	//	*RoutingRuleSpec_Retries
	//	*RoutingRuleSpec_CorsPolicy
	//	*RoutingRuleSpec_Mirror
	//	*RoutingRuleSpec_HeaderManipulation
	RuleType             isRoutingRuleSpec_RuleType `protobuf_oneof:"rule_type"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *RoutingRuleSpec) Reset()         { *m = RoutingRuleSpec{} }
func (m *RoutingRuleSpec) String() string { return proto.CompactTextString(m) }
func (*RoutingRuleSpec) ProtoMessage()    {}
func (*RoutingRuleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{1}
}
func (m *RoutingRuleSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoutingRuleSpec.Unmarshal(m, b)
}
func (m *RoutingRuleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoutingRuleSpec.Marshal(b, m, deterministic)
}
func (m *RoutingRuleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoutingRuleSpec.Merge(m, src)
}
func (m *RoutingRuleSpec) XXX_Size() int {
	return xxx_messageInfo_RoutingRuleSpec.Size(m)
}
func (m *RoutingRuleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RoutingRuleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RoutingRuleSpec proto.InternalMessageInfo

type isRoutingRuleSpec_RuleType interface {
	isRoutingRuleSpec_RuleType()
	Equal(interface{}) bool
}

type RoutingRuleSpec_TrafficShifting struct {
	TrafficShifting *TrafficShifting `protobuf:"bytes,1,opt,name=traffic_shifting,json=trafficShifting,proto3,oneof"`
}
type RoutingRuleSpec_FaultInjection struct {
	FaultInjection *FaultInjection `protobuf:"bytes,2,opt,name=fault_injection,json=faultInjection,proto3,oneof"`
}
type RoutingRuleSpec_RequestTimeout struct {
	RequestTimeout *types.Duration `protobuf:"bytes,7,opt,name=request_timeout,json=requestTimeout,proto3,oneof"`
}
type RoutingRuleSpec_Retries struct {
	Retries *v1alpha3.HTTPRetry `protobuf:"bytes,8,opt,name=retries,proto3,oneof"`
}
type RoutingRuleSpec_CorsPolicy struct {
	CorsPolicy *v1alpha3.CorsPolicy `protobuf:"bytes,10,opt,name=cors_policy,json=corsPolicy,proto3,oneof"`
}
type RoutingRuleSpec_Mirror struct {
	Mirror *v1.Destination `protobuf:"bytes,9,opt,name=mirror,proto3,oneof"`
}
type RoutingRuleSpec_HeaderManipulation struct {
	HeaderManipulation *HeaderManipulation `protobuf:"bytes,12,opt,name=header_manipulation,json=headerManipulation,proto3,oneof"`
}

func (*RoutingRuleSpec_TrafficShifting) isRoutingRuleSpec_RuleType()    {}
func (*RoutingRuleSpec_FaultInjection) isRoutingRuleSpec_RuleType()     {}
func (*RoutingRuleSpec_RequestTimeout) isRoutingRuleSpec_RuleType()     {}
func (*RoutingRuleSpec_Retries) isRoutingRuleSpec_RuleType()            {}
func (*RoutingRuleSpec_CorsPolicy) isRoutingRuleSpec_RuleType()         {}
func (*RoutingRuleSpec_Mirror) isRoutingRuleSpec_RuleType()             {}
func (*RoutingRuleSpec_HeaderManipulation) isRoutingRuleSpec_RuleType() {}

func (m *RoutingRuleSpec) GetRuleType() isRoutingRuleSpec_RuleType {
	if m != nil {
		return m.RuleType
	}
	return nil
}

func (m *RoutingRuleSpec) GetTrafficShifting() *TrafficShifting {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_TrafficShifting); ok {
		return x.TrafficShifting
	}
	return nil
}

func (m *RoutingRuleSpec) GetFaultInjection() *FaultInjection {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_FaultInjection); ok {
		return x.FaultInjection
	}
	return nil
}

func (m *RoutingRuleSpec) GetRequestTimeout() *types.Duration {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_RequestTimeout); ok {
		return x.RequestTimeout
	}
	return nil
}

func (m *RoutingRuleSpec) GetRetries() *v1alpha3.HTTPRetry {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_Retries); ok {
		return x.Retries
	}
	return nil
}

func (m *RoutingRuleSpec) GetCorsPolicy() *v1alpha3.CorsPolicy {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_CorsPolicy); ok {
		return x.CorsPolicy
	}
	return nil
}

func (m *RoutingRuleSpec) GetMirror() *v1.Destination {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_Mirror); ok {
		return x.Mirror
	}
	return nil
}

func (m *RoutingRuleSpec) GetHeaderManipulation() *HeaderManipulation {
	if x, ok := m.GetRuleType().(*RoutingRuleSpec_HeaderManipulation); ok {
		return x.HeaderManipulation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RoutingRuleSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RoutingRuleSpec_OneofMarshaler, _RoutingRuleSpec_OneofUnmarshaler, _RoutingRuleSpec_OneofSizer, []interface{}{
		(*RoutingRuleSpec_TrafficShifting)(nil),
		(*RoutingRuleSpec_FaultInjection)(nil),
		(*RoutingRuleSpec_RequestTimeout)(nil),
		(*RoutingRuleSpec_Retries)(nil),
		(*RoutingRuleSpec_CorsPolicy)(nil),
		(*RoutingRuleSpec_Mirror)(nil),
		(*RoutingRuleSpec_HeaderManipulation)(nil),
	}
}

func _RoutingRuleSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RoutingRuleSpec)
	// rule_type
	switch x := m.RuleType.(type) {
	case *RoutingRuleSpec_TrafficShifting:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TrafficShifting); err != nil {
			return err
		}
	case *RoutingRuleSpec_FaultInjection:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FaultInjection); err != nil {
			return err
		}
	case *RoutingRuleSpec_RequestTimeout:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RequestTimeout); err != nil {
			return err
		}
	case *RoutingRuleSpec_Retries:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Retries); err != nil {
			return err
		}
	case *RoutingRuleSpec_CorsPolicy:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CorsPolicy); err != nil {
			return err
		}
	case *RoutingRuleSpec_Mirror:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Mirror); err != nil {
			return err
		}
	case *RoutingRuleSpec_HeaderManipulation:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HeaderManipulation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RoutingRuleSpec.RuleType has unexpected type %T", x)
	}
	return nil
}

func _RoutingRuleSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RoutingRuleSpec)
	switch tag {
	case 1: // rule_type.traffic_shifting
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TrafficShifting)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_TrafficShifting{msg}
		return true, err
	case 2: // rule_type.fault_injection
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FaultInjection)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_FaultInjection{msg}
		return true, err
	case 7: // rule_type.request_timeout
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(types.Duration)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_RequestTimeout{msg}
		return true, err
	case 8: // rule_type.retries
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(v1alpha3.HTTPRetry)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_Retries{msg}
		return true, err
	case 10: // rule_type.cors_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(v1alpha3.CorsPolicy)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_CorsPolicy{msg}
		return true, err
	case 9: // rule_type.mirror
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(v1.Destination)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_Mirror{msg}
		return true, err
	case 12: // rule_type.header_manipulation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HeaderManipulation)
		err := b.DecodeMessage(msg)
		m.RuleType = &RoutingRuleSpec_HeaderManipulation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RoutingRuleSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RoutingRuleSpec)
	// rule_type
	switch x := m.RuleType.(type) {
	case *RoutingRuleSpec_TrafficShifting:
		s := proto.Size(x.TrafficShifting)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_FaultInjection:
		s := proto.Size(x.FaultInjection)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_RequestTimeout:
		s := proto.Size(x.RequestTimeout)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_Retries:
		s := proto.Size(x.Retries)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_CorsPolicy:
		s := proto.Size(x.CorsPolicy)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_Mirror:
		s := proto.Size(x.Mirror)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RoutingRuleSpec_HeaderManipulation:
		s := proto.Size(x.HeaderManipulation)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// requests for this rule will be routed to these destinations
type TrafficShifting struct {
	// split traffic between these subsets based on their weights
	// weights are relative to the sum of the weights
	Destinations         *v1.MultiDestination `protobuf:"bytes,1,opt,name=destinations,proto3" json:"destinations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TrafficShifting) Reset()         { *m = TrafficShifting{} }
func (m *TrafficShifting) String() string { return proto.CompactTextString(m) }
func (*TrafficShifting) ProtoMessage()    {}
func (*TrafficShifting) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{2}
}
func (m *TrafficShifting) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficShifting.Unmarshal(m, b)
}
func (m *TrafficShifting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficShifting.Marshal(b, m, deterministic)
}
func (m *TrafficShifting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficShifting.Merge(m, src)
}
func (m *TrafficShifting) XXX_Size() int {
	return xxx_messageInfo_TrafficShifting.Size(m)
}
func (m *TrafficShifting) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficShifting.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficShifting proto.InternalMessageInfo

func (m *TrafficShifting) GetDestinations() *v1.MultiDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

// FaultInjection can be used to specify one or more faults to inject
// while forwarding http requests to the destination specified in a route.
// Faults include aborting the Http request from downstream service, and/or delaying
// proxying of requests. A fault rule MUST HAVE delay or abort.
type FaultInjection struct {
	// Types that are valid to be assigned to FaultInjectionType:
	//	*FaultInjection_Delay_
	//	*FaultInjection_Abort_
	FaultInjectionType isFaultInjection_FaultInjectionType `protobuf_oneof:"fault_injection_type"`
	// Percentage of requests to be faulted with the error code provided.
	Percentage           float64  `protobuf:"fixed64,5,opt,name=percentage,proto3" json:"percentage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FaultInjection) Reset()         { *m = FaultInjection{} }
func (m *FaultInjection) String() string { return proto.CompactTextString(m) }
func (*FaultInjection) ProtoMessage()    {}
func (*FaultInjection) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{3}
}
func (m *FaultInjection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FaultInjection.Unmarshal(m, b)
}
func (m *FaultInjection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FaultInjection.Marshal(b, m, deterministic)
}
func (m *FaultInjection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FaultInjection.Merge(m, src)
}
func (m *FaultInjection) XXX_Size() int {
	return xxx_messageInfo_FaultInjection.Size(m)
}
func (m *FaultInjection) XXX_DiscardUnknown() {
	xxx_messageInfo_FaultInjection.DiscardUnknown(m)
}

var xxx_messageInfo_FaultInjection proto.InternalMessageInfo

type isFaultInjection_FaultInjectionType interface {
	isFaultInjection_FaultInjectionType()
	Equal(interface{}) bool
}

type FaultInjection_Delay_ struct {
	Delay *FaultInjection_Delay `protobuf:"bytes,1,opt,name=delay,proto3,oneof"`
}
type FaultInjection_Abort_ struct {
	Abort *FaultInjection_Abort `protobuf:"bytes,2,opt,name=abort,proto3,oneof"`
}

func (*FaultInjection_Delay_) isFaultInjection_FaultInjectionType() {}
func (*FaultInjection_Abort_) isFaultInjection_FaultInjectionType() {}

func (m *FaultInjection) GetFaultInjectionType() isFaultInjection_FaultInjectionType {
	if m != nil {
		return m.FaultInjectionType
	}
	return nil
}

func (m *FaultInjection) GetDelay() *FaultInjection_Delay {
	if x, ok := m.GetFaultInjectionType().(*FaultInjection_Delay_); ok {
		return x.Delay
	}
	return nil
}

func (m *FaultInjection) GetAbort() *FaultInjection_Abort {
	if x, ok := m.GetFaultInjectionType().(*FaultInjection_Abort_); ok {
		return x.Abort
	}
	return nil
}

func (m *FaultInjection) GetPercentage() float64 {
	if m != nil {
		return m.Percentage
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FaultInjection) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FaultInjection_OneofMarshaler, _FaultInjection_OneofUnmarshaler, _FaultInjection_OneofSizer, []interface{}{
		(*FaultInjection_Delay_)(nil),
		(*FaultInjection_Abort_)(nil),
	}
}

func _FaultInjection_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FaultInjection)
	// fault_injection_type
	switch x := m.FaultInjectionType.(type) {
	case *FaultInjection_Delay_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Delay); err != nil {
			return err
		}
	case *FaultInjection_Abort_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Abort); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FaultInjection.FaultInjectionType has unexpected type %T", x)
	}
	return nil
}

func _FaultInjection_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FaultInjection)
	switch tag {
	case 1: // fault_injection_type.delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FaultInjection_Delay)
		err := b.DecodeMessage(msg)
		m.FaultInjectionType = &FaultInjection_Delay_{msg}
		return true, err
	case 2: // fault_injection_type.abort
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FaultInjection_Abort)
		err := b.DecodeMessage(msg)
		m.FaultInjectionType = &FaultInjection_Abort_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FaultInjection_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FaultInjection)
	// fault_injection_type
	switch x := m.FaultInjectionType.(type) {
	case *FaultInjection_Delay_:
		s := proto.Size(x.Delay)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FaultInjection_Abort_:
		s := proto.Size(x.Abort)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The _fixedDelay_ field is used to indicate the amount of delay in seconds.
// The optional _percentage_ field can be used to only delay a certain
// percentage of requests. If left unspecified, all request will be delayed.
type FaultInjection_Delay struct {
	// Types that are valid to be assigned to HttpDelayType:
	//	*FaultInjection_Delay_FixedDelay
	HttpDelayType        isFaultInjection_Delay_HttpDelayType `protobuf_oneof:"http_delay_type"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *FaultInjection_Delay) Reset()         { *m = FaultInjection_Delay{} }
func (m *FaultInjection_Delay) String() string { return proto.CompactTextString(m) }
func (*FaultInjection_Delay) ProtoMessage()    {}
func (*FaultInjection_Delay) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{3, 0}
}
func (m *FaultInjection_Delay) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FaultInjection_Delay.Unmarshal(m, b)
}
func (m *FaultInjection_Delay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FaultInjection_Delay.Marshal(b, m, deterministic)
}
func (m *FaultInjection_Delay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FaultInjection_Delay.Merge(m, src)
}
func (m *FaultInjection_Delay) XXX_Size() int {
	return xxx_messageInfo_FaultInjection_Delay.Size(m)
}
func (m *FaultInjection_Delay) XXX_DiscardUnknown() {
	xxx_messageInfo_FaultInjection_Delay.DiscardUnknown(m)
}

var xxx_messageInfo_FaultInjection_Delay proto.InternalMessageInfo

type isFaultInjection_Delay_HttpDelayType interface {
	isFaultInjection_Delay_HttpDelayType()
	Equal(interface{}) bool
}

type FaultInjection_Delay_FixedDelay struct {
	FixedDelay *time.Duration `protobuf:"bytes,3,opt,name=fixed_delay,json=fixedDelay,proto3,oneof,stdduration"`
}

func (*FaultInjection_Delay_FixedDelay) isFaultInjection_Delay_HttpDelayType() {}

func (m *FaultInjection_Delay) GetHttpDelayType() isFaultInjection_Delay_HttpDelayType {
	if m != nil {
		return m.HttpDelayType
	}
	return nil
}

func (m *FaultInjection_Delay) GetFixedDelay() *time.Duration {
	if x, ok := m.GetHttpDelayType().(*FaultInjection_Delay_FixedDelay); ok {
		return x.FixedDelay
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FaultInjection_Delay) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FaultInjection_Delay_OneofMarshaler, _FaultInjection_Delay_OneofUnmarshaler, _FaultInjection_Delay_OneofSizer, []interface{}{
		(*FaultInjection_Delay_FixedDelay)(nil),
	}
}

func _FaultInjection_Delay_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *FaultInjection_Delay_FixedDelay:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		dAtA, err := github_com_gogo_protobuf_types.StdDurationMarshal(*x.FixedDelay)
		if err != nil {
			return err
		}
		if err := b.EncodeRawBytes(dAtA); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FaultInjection_Delay.HttpDelayType has unexpected type %T", x)
	}
	return nil
}

func _FaultInjection_Delay_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FaultInjection_Delay)
	switch tag {
	case 3: // http_delay_type.fixed_delay
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		if err != nil {
			return true, err
		}
		c := new(time.Duration)
		if err2 := github_com_gogo_protobuf_types.StdDurationUnmarshal(c, x); err2 != nil {
			return true, err
		}
		m.HttpDelayType = &FaultInjection_Delay_FixedDelay{c}
		return true, err
	default:
		return false, nil
	}
}

func _FaultInjection_Delay_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FaultInjection_Delay)
	// http_delay_type
	switch x := m.HttpDelayType.(type) {
	case *FaultInjection_Delay_FixedDelay:
		s := github_com_gogo_protobuf_types.SizeOfStdDuration(*x.FixedDelay)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The _httpStatus_ field is used to indicate the HTTP status code to
// return to the caller. The optional _percentage_ field can be used to only
// abort a certain percentage of requests. If not specified, all requests are
// aborted.
type FaultInjection_Abort struct {
	// Types that are valid to be assigned to ErrorType:
	//	*FaultInjection_Abort_HttpStatus
	ErrorType            isFaultInjection_Abort_ErrorType `protobuf_oneof:"error_type"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *FaultInjection_Abort) Reset()         { *m = FaultInjection_Abort{} }
func (m *FaultInjection_Abort) String() string { return proto.CompactTextString(m) }
func (*FaultInjection_Abort) ProtoMessage()    {}
func (*FaultInjection_Abort) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{3, 1}
}
func (m *FaultInjection_Abort) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FaultInjection_Abort.Unmarshal(m, b)
}
func (m *FaultInjection_Abort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FaultInjection_Abort.Marshal(b, m, deterministic)
}
func (m *FaultInjection_Abort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FaultInjection_Abort.Merge(m, src)
}
func (m *FaultInjection_Abort) XXX_Size() int {
	return xxx_messageInfo_FaultInjection_Abort.Size(m)
}
func (m *FaultInjection_Abort) XXX_DiscardUnknown() {
	xxx_messageInfo_FaultInjection_Abort.DiscardUnknown(m)
}

var xxx_messageInfo_FaultInjection_Abort proto.InternalMessageInfo

type isFaultInjection_Abort_ErrorType interface {
	isFaultInjection_Abort_ErrorType()
	Equal(interface{}) bool
}

type FaultInjection_Abort_HttpStatus struct {
	HttpStatus int32 `protobuf:"varint,4,opt,name=http_status,json=httpStatus,proto3,oneof"`
}

func (*FaultInjection_Abort_HttpStatus) isFaultInjection_Abort_ErrorType() {}

func (m *FaultInjection_Abort) GetErrorType() isFaultInjection_Abort_ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return nil
}

func (m *FaultInjection_Abort) GetHttpStatus() int32 {
	if x, ok := m.GetErrorType().(*FaultInjection_Abort_HttpStatus); ok {
		return x.HttpStatus
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FaultInjection_Abort) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FaultInjection_Abort_OneofMarshaler, _FaultInjection_Abort_OneofUnmarshaler, _FaultInjection_Abort_OneofSizer, []interface{}{
		(*FaultInjection_Abort_HttpStatus)(nil),
	}
}

func _FaultInjection_Abort_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *FaultInjection_Abort_HttpStatus:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		return fmt.Errorf("FaultInjection_Abort.ErrorType has unexpected type %T", x)
	}
	return nil
}

func _FaultInjection_Abort_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FaultInjection_Abort)
	switch tag {
	case 4: // error_type.http_status
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ErrorType = &FaultInjection_Abort_HttpStatus{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _FaultInjection_Abort_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FaultInjection_Abort)
	// error_type
	switch x := m.ErrorType.(type) {
	case *FaultInjection_Abort_HttpStatus:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.HttpStatus))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// manipulate request and response headers
type HeaderManipulation struct {
	// HTTP headers to remove before returning a response to the caller.
	RemoveResponseHeaders []string `protobuf:"bytes,12,rep,name=remove_response_headers,json=removeResponseHeaders,proto3" json:"remove_response_headers,omitempty"`
	// Additional HTTP headers to add before returning a response to the
	// caller.
	AppendResponseHeaders map[string]string `protobuf:"bytes,13,rep,name=append_response_headers,json=appendResponseHeaders,proto3" json:"append_response_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// HTTP headers to remove before forwarding a request to the
	// destination service.
	RemoveRequestHeaders []string `protobuf:"bytes,14,rep,name=remove_request_headers,json=removeRequestHeaders,proto3" json:"remove_request_headers,omitempty"`
	// Additional HTTP headers to add before forwarding a request to the
	// destination service.
	AppendRequestHeaders map[string]string `protobuf:"bytes,15,rep,name=append_request_headers,json=appendRequestHeaders,proto3" json:"append_request_headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HeaderManipulation) Reset()         { *m = HeaderManipulation{} }
func (m *HeaderManipulation) String() string { return proto.CompactTextString(m) }
func (*HeaderManipulation) ProtoMessage()    {}
func (*HeaderManipulation) Descriptor() ([]byte, []int) {
	return fileDescriptor_29316bfaa5f4ba1a, []int{4}
}
func (m *HeaderManipulation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeaderManipulation.Unmarshal(m, b)
}
func (m *HeaderManipulation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeaderManipulation.Marshal(b, m, deterministic)
}
func (m *HeaderManipulation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderManipulation.Merge(m, src)
}
func (m *HeaderManipulation) XXX_Size() int {
	return xxx_messageInfo_HeaderManipulation.Size(m)
}
func (m *HeaderManipulation) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderManipulation.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderManipulation proto.InternalMessageInfo

func (m *HeaderManipulation) GetRemoveResponseHeaders() []string {
	if m != nil {
		return m.RemoveResponseHeaders
	}
	return nil
}

func (m *HeaderManipulation) GetAppendResponseHeaders() map[string]string {
	if m != nil {
		return m.AppendResponseHeaders
	}
	return nil
}

func (m *HeaderManipulation) GetRemoveRequestHeaders() []string {
	if m != nil {
		return m.RemoveRequestHeaders
	}
	return nil
}

func (m *HeaderManipulation) GetAppendRequestHeaders() map[string]string {
	if m != nil {
		return m.AppendRequestHeaders
	}
	return nil
}

func init() {
	proto.RegisterType((*RoutingRule)(nil), "supergloo.solo.io.RoutingRule")
	proto.RegisterType((*RoutingRuleSpec)(nil), "supergloo.solo.io.RoutingRuleSpec")
	proto.RegisterType((*TrafficShifting)(nil), "supergloo.solo.io.TrafficShifting")
	proto.RegisterType((*FaultInjection)(nil), "supergloo.solo.io.FaultInjection")
	proto.RegisterType((*FaultInjection_Delay)(nil), "supergloo.solo.io.FaultInjection.Delay")
	proto.RegisterType((*FaultInjection_Abort)(nil), "supergloo.solo.io.FaultInjection.Abort")
	proto.RegisterType((*HeaderManipulation)(nil), "supergloo.solo.io.HeaderManipulation")
	proto.RegisterMapType((map[string]string)(nil), "supergloo.solo.io.HeaderManipulation.AppendRequestHeadersEntry")
	proto.RegisterMapType((map[string]string)(nil), "supergloo.solo.io.HeaderManipulation.AppendResponseHeadersEntry")
}

func init() {
	proto.RegisterFile("github.com/solo-io/supergloo/api/v1/routing.proto", fileDescriptor_29316bfaa5f4ba1a)
}

var fileDescriptor_29316bfaa5f4ba1a = []byte{
	// 1024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xb6, 0x63, 0xbb, 0x6d, 0x9e, 0x43, 0xdc, 0x4e, 0x9d, 0x74, 0xeb, 0x43, 0x9a, 0x46, 0xa0,
	0xe6, 0x40, 0x77, 0x95, 0x04, 0x55, 0x51, 0x2e, 0x4d, 0x4d, 0xa0, 0x46, 0x22, 0x22, 0x4c, 0x82,
	0x84, 0x38, 0xb0, 0x9a, 0xac, 0x9f, 0xed, 0x21, 0xeb, 0x9d, 0x65, 0x66, 0xd6, 0xc4, 0xd7, 0x1e,
	0xf8, 0x0d, 0x9c, 0x38, 0xf3, 0x53, 0xf8, 0x15, 0x20, 0x21, 0x2e, 0x1c, 0xfb, 0x0f, 0xd0, 0xce,
	0xcc, 0x3a, 0x76, 0xe2, 0xb6, 0xce, 0x29, 0x99, 0x79, 0xdf, 0xf7, 0xcd, 0xb7, 0xf3, 0xbe, 0x37,
	0x32, 0xec, 0xf4, 0xb9, 0x1e, 0x64, 0xe7, 0x7e, 0x24, 0x86, 0x81, 0x12, 0xb1, 0x78, 0xce, 0x45,
	0xa0, 0xb2, 0x14, 0x65, 0x3f, 0x16, 0x22, 0x60, 0x29, 0x0f, 0x46, 0x3b, 0x81, 0x14, 0x99, 0xe6,
	0x49, 0xdf, 0x4f, 0xa5, 0xd0, 0x82, 0x3c, 0x98, 0xd4, 0xfd, 0x9c, 0xe1, 0x73, 0xd1, 0x6a, 0xf6,
	0x45, 0x5f, 0x98, 0x6a, 0x90, 0xff, 0x67, 0x81, 0xad, 0x8d, 0xbe, 0x10, 0xfd, 0x18, 0x03, 0xb3,
	0x3a, 0xcf, 0x7a, 0x41, 0x37, 0x93, 0x4c, 0x73, 0x91, 0xb8, 0xfa, 0xee, 0x22, 0x67, 0x2b, 0x8c,
	0x31, 0xd2, 0x42, 0x3a, 0xce, 0xfe, 0x1c, 0x8e, 0x81, 0xa7, 0x52, 0xfc, 0x84, 0x91, 0x56, 0xc1,
	0x34, 0x39, 0x95, 0xe2, 0x72, 0xec, 0x98, 0x01, 0x57, 0x9a, 0x8b, 0x20, 0x41, 0xfd, 0x8b, 0x90,
	0x17, 0x3c, 0xe9, 0x07, 0xa3, 0x1d, 0x16, 0xa7, 0x03, 0xb6, 0x17, 0x8c, 0xb8, 0xd4, 0x19, 0x8b,
	0x43, 0x85, 0x72, 0xc4, 0x23, 0x74, 0x84, 0xb9, 0x57, 0x93, 0xff, 0xbd, 0xe0, 0xba, 0x38, 0x60,
	0x88, 0x9a, 0x75, 0x99, 0x66, 0xc5, 0x19, 0x0b, 0x50, 0x94, 0x66, 0x3a, 0x53, 0x8e, 0xf0, 0xe9,
	0x02, 0x04, 0x89, 0xbd, 0x5b, 0x38, 0x2a, 0xd6, 0x96, 0xb2, 0xf5, 0x5f, 0x05, 0xea, 0xd4, 0xb6,
	0x8f, 0x66, 0x31, 0x92, 0x5d, 0xb8, 0x63, 0x0d, 0x78, 0xdd, 0xcd, 0xf2, 0x76, 0x7d, 0xb7, 0xe9,
	0x47, 0x42, 0x62, 0xd1, 0x48, 0xff, 0xd4, 0xd4, 0xda, 0xd5, 0x3f, 0xff, 0x7a, 0x52, 0xa2, 0x0e,
	0x49, 0xf6, 0xe1, 0x5e, 0xf1, 0x9d, 0x1e, 0x1a, 0xd6, 0xfa, 0x2c, 0xeb, 0xd8, 0x55, 0x1d, 0x6f,
	0x82, 0x26, 0x07, 0x50, 0xd7, 0x4c, 0xf6, 0x51, 0x87, 0x43, 0x54, 0x03, 0xaf, 0x6c, 0xc8, 0x8f,
	0x67, 0xc9, 0x14, 0x95, 0xc8, 0x64, 0x84, 0x14, 0x7b, 0x14, 0x2c, 0xfa, 0x18, 0xd5, 0x80, 0xbc,
	0x86, 0x86, 0x2d, 0x84, 0x45, 0x04, 0xbc, 0x25, 0xc3, 0xdf, 0xf0, 0x6f, 0x04, 0xd0, 0x3f, 0x11,
	0xdd, 0x53, 0x87, 0xa2, 0xab, 0x96, 0x56, 0xac, 0xc9, 0xb7, 0xd0, 0xec, 0xa2, 0xd2, 0x3c, 0x31,
	0xd9, 0xbb, 0x52, 0xab, 0x2c, 0xa4, 0xf6, 0x70, 0x8a, 0x3b, 0x91, 0x3c, 0x84, 0xfb, 0x12, 0x7f,
	0xce, 0x50, 0xe9, 0x70, 0xc8, 0x74, 0x34, 0x40, 0xa9, 0xbc, 0xea, 0x66, 0x65, 0xbb, 0xbe, 0xbb,
	0xe6, 0xcf, 0x28, 0x1d, 0xdb, 0x2a, 0x6d, 0x38, 0xb8, 0x5b, 0x2b, 0xf2, 0x02, 0xaa, 0x2a, 0xc5,
	0xc8, 0xab, 0x19, 0x13, 0x5b, 0x73, 0x4c, 0x4c, 0x75, 0xed, 0x34, 0xc5, 0x88, 0x1a, 0xfc, 0x41,
	0xeb, 0xcd, 0xdb, 0x6a, 0x15, 0x96, 0xa4, 0x7c, 0xf3, 0xb6, 0xba, 0x4a, 0x56, 0xdc, 0x64, 0xca,
	0x2c, 0x46, 0xb5, 0xf5, 0x7b, 0x15, 0x1a, 0xd7, 0x58, 0xe4, 0x1b, 0xb8, 0xaf, 0x25, 0xeb, 0xf5,
	0x78, 0x14, 0xaa, 0x01, 0xef, 0xe5, 0x35, 0xd7, 0x86, 0x79, 0x67, 0x9e, 0x59, 0xe8, 0xa9, 0x43,
	0x76, 0x4a, 0xb4, 0xa1, 0x67, 0xb7, 0xc8, 0xd7, 0xd0, 0xe8, 0xb1, 0x2c, 0xd6, 0x21, 0x4f, 0xf2,
	0x79, 0xe3, 0x22, 0x71, 0x6d, 0x79, 0x3a, 0x47, 0xef, 0xcb, 0x1c, 0xf9, 0x55, 0x01, 0xec, 0x94,
	0xe8, 0x6a, 0x6f, 0x66, 0x87, 0x1c, 0x41, 0x71, 0x33, 0xa1, 0xe6, 0x43, 0x14, 0x99, 0xf6, 0xee,
	0xba, 0x90, 0xd8, 0xc7, 0xc3, 0x2f, 0x1e, 0x0f, 0xff, 0xc8, 0x3d, 0x1e, 0xb9, 0x8a, 0xe3, 0x9c,
	0x59, 0x0a, 0x39, 0x84, 0xbb, 0x12, 0xb5, 0xe4, 0xa8, 0xbc, 0x7b, 0x86, 0xfd, 0xb1, 0x6f, 0x86,
	0xdd, 0xbf, 0x1a, 0x76, 0xbf, 0x18, 0x76, 0xbf, 0x73, 0x76, 0x76, 0x42, 0x51, 0xcb, 0x71, 0xa7,
	0x44, 0x0b, 0x1a, 0xe9, 0x40, 0x3d, 0x12, 0x52, 0x85, 0xa9, 0x88, 0x79, 0x34, 0xf6, 0xc0, 0xa8,
	0x7c, 0xf2, 0x1e, 0x95, 0xcf, 0x85, 0x54, 0x27, 0x06, 0xdc, 0x29, 0x51, 0x88, 0x26, 0x2b, 0xb2,
	0x07, 0x77, 0x86, 0x5c, 0x4a, 0x21, 0xbd, 0xe5, 0xe2, 0x43, 0xa6, 0x6f, 0xe4, 0xe8, 0x2a, 0x4d,
	0x9d, 0x12, 0x75, 0x50, 0xf2, 0x3d, 0x3c, 0x1c, 0x20, 0xeb, 0xa2, 0x0c, 0x87, 0x2c, 0xe1, 0x69,
	0x16, 0x1b, 0x80, 0xb7, 0xe2, 0x6c, 0xdc, 0xbc, 0xd8, 0x8e, 0x41, 0x1f, 0x4f, 0x81, 0x3b, 0x25,
	0x4a, 0x06, 0x37, 0x76, 0xdb, 0x75, 0x58, 0xce, 0xc3, 0x11, 0xea, 0x71, 0x8a, 0x5b, 0xdf, 0x41,
	0xe3, 0x5a, 0x87, 0x49, 0x1b, 0x56, 0xa6, 0x02, 0xae, 0x5c, 0x36, 0x36, 0xae, 0xa5, 0x38, 0x8b,
	0x35, 0x9f, 0x72, 0x4e, 0x67, 0x38, 0x5b, 0xff, 0x2e, 0xc1, 0xea, 0x6c, 0xa7, 0xc9, 0x4b, 0xa8,
	0x75, 0x31, 0x66, 0x63, 0xa7, 0xf7, 0xec, 0x83, 0xd9, 0xf0, 0x8f, 0x72, 0x78, 0xa7, 0x44, 0x2d,
	0x2f, 0x17, 0x60, 0xe7, 0x42, 0x6a, 0x17, 0xae, 0x05, 0x04, 0x5e, 0xe5, 0xf0, 0x5c, 0xc0, 0xf0,
	0xc8, 0x06, 0x40, 0x8a, 0x32, 0xc2, 0x44, 0xb3, 0x3e, 0x9a, 0x31, 0x2b, 0xd3, 0xa9, 0x9d, 0xd6,
	0x8f, 0x50, 0x33, 0x47, 0x92, 0x36, 0xd4, 0x7b, 0xfc, 0x12, 0xbb, 0xa1, 0x35, 0x5c, 0xf9, 0x40,
	0xfc, 0xda, 0xd5, 0xdf, 0xfe, 0x7e, 0x52, 0xce, 0x9b, 0x6e, 0x58, 0x46, 0xa3, 0xfd, 0x00, 0x1a,
	0x03, 0xad, 0x53, 0x2b, 0x61, 0xee, 0xba, 0xb5, 0x0f, 0x35, 0xe3, 0x88, 0x3c, 0x85, 0xba, 0xa9,
	0xb9, 0x67, 0xb7, 0xba, 0x59, 0xde, 0xae, 0xe5, 0xf4, 0x7c, 0xd3, 0x3d, 0xb7, 0x2b, 0x00, 0x98,
	0xe7, 0xc0, 0x30, 0xdb, 0xeb, 0xd0, 0xbc, 0x36, 0x61, 0xb6, 0x7b, 0xbf, 0x56, 0x81, 0xdc, 0xec,
	0x3b, 0x79, 0x01, 0x8f, 0x24, 0x0e, 0xc5, 0x08, 0x43, 0x89, 0x2a, 0x15, 0x89, 0xc2, 0xd0, 0xe6,
	0x40, 0x79, 0x2b, 0x9b, 0x95, 0xed, 0x65, 0xba, 0x66, 0xcb, 0xd4, 0x55, 0xad, 0x84, 0x22, 0x97,
	0xf0, 0x88, 0xa5, 0x29, 0x26, 0xdd, 0x9b, 0xbc, 0x8f, 0xcc, 0x53, 0x76, 0xb8, 0x50, 0xee, 0xfc,
	0x57, 0x46, 0xe4, 0x9a, 0xfa, 0x17, 0x89, 0x96, 0x63, 0xba, 0xc6, 0xe6, 0xd5, 0xc8, 0x67, 0xb0,
	0x3e, 0x71, 0x6c, 0x67, 0xbf, 0x38, 0x78, 0xd5, 0x18, 0x6e, 0x16, 0x86, 0x4d, 0xb1, 0x60, 0x65,
	0xb0, 0x3e, 0xf1, 0x3b, 0xcb, 0x6a, 0x18, 0xbb, 0x2f, 0x6f, 0x67, 0x77, 0x5a, 0xdb, 0xba, 0x6d,
	0xb2, 0x39, 0xa5, 0x56, 0x07, 0x5a, 0xef, 0xfe, 0x42, 0x72, 0x1f, 0x2a, 0x17, 0x68, 0x53, 0xbe,
	0x4c, 0xf3, 0x7f, 0x49, 0x13, 0x6a, 0x23, 0x16, 0x67, 0x68, 0x82, 0xbb, 0x4c, 0xed, 0xe2, 0x60,
	0x69, 0xbf, 0xdc, 0x7a, 0x0d, 0x8f, 0xdf, 0x79, 0xf8, 0x6d, 0x84, 0xda, 0xcf, 0xff, 0xf8, 0x67,
	0xa3, 0xfc, 0xc3, 0xb3, 0xf7, 0xfe, 0x7a, 0x4a, 0x2f, 0xfa, 0xee, 0x17, 0xc1, 0xf9, 0x1d, 0x93,
	0xe1, 0xbd, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf0, 0xe6, 0x0e, 0xdf, 0xeb, 0x09, 0x00, 0x00,
}

func (this *RoutingRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRule)
	if !ok {
		that2, ok := that.(RoutingRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if !this.TargetMesh.Equal(that1.TargetMesh) {
		return false
	}
	if !this.SourceSelector.Equal(that1.SourceSelector) {
		return false
	}
	if !this.DestinationSelector.Equal(that1.DestinationSelector) {
		return false
	}
	if len(this.RequestMatchers) != len(that1.RequestMatchers) {
		return false
	}
	for i := range this.RequestMatchers {
		if !this.RequestMatchers[i].Equal(that1.RequestMatchers[i]) {
			return false
		}
	}
	if !this.Spec.Equal(that1.Spec) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec)
	if !ok {
		that2, ok := that.(RoutingRuleSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RuleType == nil {
		if this.RuleType != nil {
			return false
		}
	} else if this.RuleType == nil {
		return false
	} else if !this.RuleType.Equal(that1.RuleType) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_TrafficShifting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_TrafficShifting)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_TrafficShifting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TrafficShifting.Equal(that1.TrafficShifting) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_FaultInjection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_FaultInjection)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_FaultInjection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FaultInjection.Equal(that1.FaultInjection) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_RequestTimeout) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_RequestTimeout)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_RequestTimeout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestTimeout.Equal(that1.RequestTimeout) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_Retries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_Retries)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_Retries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Retries.Equal(that1.Retries) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_CorsPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_CorsPolicy)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_CorsPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CorsPolicy.Equal(that1.CorsPolicy) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_Mirror) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_Mirror)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_Mirror)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Mirror.Equal(that1.Mirror) {
		return false
	}
	return true
}
func (this *RoutingRuleSpec_HeaderManipulation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoutingRuleSpec_HeaderManipulation)
	if !ok {
		that2, ok := that.(RoutingRuleSpec_HeaderManipulation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeaderManipulation.Equal(that1.HeaderManipulation) {
		return false
	}
	return true
}
func (this *TrafficShifting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrafficShifting)
	if !ok {
		that2, ok := that.(TrafficShifting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Destinations.Equal(that1.Destinations) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection)
	if !ok {
		that2, ok := that.(FaultInjection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.FaultInjectionType == nil {
		if this.FaultInjectionType != nil {
			return false
		}
	} else if this.FaultInjectionType == nil {
		return false
	} else if !this.FaultInjectionType.Equal(that1.FaultInjectionType) {
		return false
	}
	if this.Percentage != that1.Percentage {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection_Delay_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Delay_)
	if !ok {
		that2, ok := that.(FaultInjection_Delay_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Delay.Equal(that1.Delay) {
		return false
	}
	return true
}
func (this *FaultInjection_Abort_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Abort_)
	if !ok {
		that2, ok := that.(FaultInjection_Abort_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Abort.Equal(that1.Abort) {
		return false
	}
	return true
}
func (this *FaultInjection_Delay) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Delay)
	if !ok {
		that2, ok := that.(FaultInjection_Delay)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HttpDelayType == nil {
		if this.HttpDelayType != nil {
			return false
		}
	} else if this.HttpDelayType == nil {
		return false
	} else if !this.HttpDelayType.Equal(that1.HttpDelayType) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection_Delay_FixedDelay) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Delay_FixedDelay)
	if !ok {
		that2, ok := that.(FaultInjection_Delay_FixedDelay)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FixedDelay != nil && that1.FixedDelay != nil {
		if *this.FixedDelay != *that1.FixedDelay {
			return false
		}
	} else if this.FixedDelay != nil {
		return false
	} else if that1.FixedDelay != nil {
		return false
	}
	return true
}
func (this *FaultInjection_Abort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Abort)
	if !ok {
		that2, ok := that.(FaultInjection_Abort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ErrorType == nil {
		if this.ErrorType != nil {
			return false
		}
	} else if this.ErrorType == nil {
		return false
	} else if !this.ErrorType.Equal(that1.ErrorType) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FaultInjection_Abort_HttpStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FaultInjection_Abort_HttpStatus)
	if !ok {
		that2, ok := that.(FaultInjection_Abort_HttpStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HttpStatus != that1.HttpStatus {
		return false
	}
	return true
}
func (this *HeaderManipulation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderManipulation)
	if !ok {
		that2, ok := that.(HeaderManipulation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RemoveResponseHeaders) != len(that1.RemoveResponseHeaders) {
		return false
	}
	for i := range this.RemoveResponseHeaders {
		if this.RemoveResponseHeaders[i] != that1.RemoveResponseHeaders[i] {
			return false
		}
	}
	if len(this.AppendResponseHeaders) != len(that1.AppendResponseHeaders) {
		return false
	}
	for i := range this.AppendResponseHeaders {
		if this.AppendResponseHeaders[i] != that1.AppendResponseHeaders[i] {
			return false
		}
	}
	if len(this.RemoveRequestHeaders) != len(that1.RemoveRequestHeaders) {
		return false
	}
	for i := range this.RemoveRequestHeaders {
		if this.RemoveRequestHeaders[i] != that1.RemoveRequestHeaders[i] {
			return false
		}
	}
	if len(this.AppendRequestHeaders) != len(that1.AppendRequestHeaders) {
		return false
	}
	for i := range this.AppendRequestHeaders {
		if this.AppendRequestHeaders[i] != that1.AppendRequestHeaders[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
