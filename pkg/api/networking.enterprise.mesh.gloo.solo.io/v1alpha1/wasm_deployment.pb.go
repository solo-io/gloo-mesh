// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/solo-io/gloo-mesh/api/enterprise/networking/v1alpha1/wasm_deployment.proto

package v1alpha1

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2"
	_ "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2/types"
	_ "github.com/solo-io/skv2/pkg/api/core.skv2.solo.io/v1"
	v1alpha3 "istio.io/api/networking/v1alpha3"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// WorkloadState is the state of the WasmDeployment resource as it has been applied to an individual workload.
type WasmDeploymentStatus_WorkloadState int32

const (
	// DEPLOYMENT_PENDING filters have not yet been deployed to the target workload.
	WasmDeploymentStatus_DEPLOYMENT_PENDING WasmDeploymentStatus_WorkloadState = 0
	// FILTERS_DEPLOYED indicates the WASM Filters have been deployed to the target workload (along with any cluster dependencies).
	WasmDeploymentStatus_FILTERS_DEPLOYED WasmDeploymentStatus_WorkloadState = 1
	// DEPLOYMENT_FAILED indicates Deploying the WASM Filters to this workload failed
	WasmDeploymentStatus_DEPLOYMENT_FAILED WasmDeploymentStatus_WorkloadState = 2
)

var WasmDeploymentStatus_WorkloadState_name = map[int32]string{
	0: "DEPLOYMENT_PENDING",
	1: "FILTERS_DEPLOYED",
	2: "DEPLOYMENT_FAILED",
}

var WasmDeploymentStatus_WorkloadState_value = map[string]int32{
	"DEPLOYMENT_PENDING": 0,
	"FILTERS_DEPLOYED":   1,
	"DEPLOYMENT_FAILED":  2,
}

func (x WasmDeploymentStatus_WorkloadState) String() string {
	return proto.EnumName(WasmDeploymentStatus_WorkloadState_name, int32(x))
}

func (WasmDeploymentStatus_WorkloadState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e51cfc9660b2e1a2, []int{5, 0}
}

//
//A WasmDeployment deploys one or more WASM Envoy Filters to selected Sidecars and Gateways in a Mesh.
type WasmDeploymentSpec struct {
	//
	//Sidecars/Gateways whose Workloads match these selectors will attach the specified WASM Filters.
	//Leave empty to have all workloads in the mesh apply receive the WASM Filter.
	WorkloadSelector []*v1alpha2.WorkloadSelector `protobuf:"bytes,1,rep,name=workload_selector,json=workloadSelector,proto3" json:"workload_selector,omitempty"`
	// Parameters for specifying the WASM filter
	Filters []*WasmFilterSpec `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	// weight is used to determine the order of WASM Filters when applying
	// multiple WasmDeployments to a single workload.
	// Deployed WASM filters will be sorted in order of
	// highest to lowest weight. WasmDeployments with equal weights will be
	// sorted non-deterministically.
	// Note that all WASM Filters are currently inserted just before the Envoy router filter
	// in the HTTP Connection Manager's HTTP Filter Chain.
	Weight               uint32   `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WasmDeploymentSpec) Reset()         { *m = WasmDeploymentSpec{} }
func (m *WasmDeploymentSpec) String() string { return proto.CompactTextString(m) }
func (*WasmDeploymentSpec) ProtoMessage()    {}
func (*WasmDeploymentSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e51cfc9660b2e1a2, []int{0}
}

func (m *WasmDeploymentSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WasmDeploymentSpec.Unmarshal(m, b)
}
func (m *WasmDeploymentSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WasmDeploymentSpec.Marshal(b, m, deterministic)
}
func (m *WasmDeploymentSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WasmDeploymentSpec.Merge(m, src)
}
func (m *WasmDeploymentSpec) XXX_Size() int {
	return xxx_messageInfo_WasmDeploymentSpec.Size(m)
}
func (m *WasmDeploymentSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WasmDeploymentSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WasmDeploymentSpec proto.InternalMessageInfo

func (m *WasmDeploymentSpec) GetWorkloadSelector() []*v1alpha2.WorkloadSelector {
	if m != nil {
		return m.WorkloadSelector
	}
	return nil
}

func (m *WasmDeploymentSpec) GetFilters() []*WasmFilterSpec {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *WasmDeploymentSpec) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// description of the WASM Filter to deploy
type WasmFilterSpec struct {
	// Several options are available for providing a source of the WASM filter file.
	// An option must be specified in order to execute the WasmDeployment.
	//
	// Types that are valid to be assigned to FilterSource:
	//	*WasmFilterSpec_LocalPathSource
	//	*WasmFilterSpec_HttpUriSource
	//	*WasmFilterSpec_WasmImageSource
	FilterSource isWasmFilterSpec_FilterSource `protobuf_oneof:"filter_source"`
	// Filter/service configuration used to configure or reconfigure a filter
	// (proxy_on_configuration).
	// Several options are available for providing a source of filter config (dynamic and static)/
	//
	// Types that are valid to be assigned to FilterConfigSource:
	//	*WasmFilterSpec_StaticFilterConfig
	//	*WasmFilterSpec_DynamicFilterConfig
	FilterConfigSource isWasmFilterSpec_FilterConfigSource `protobuf_oneof:"filter_config_source"`
	// the root id must match the root id
	// defined inside the filter.
	// if the user does not provide this field,
	// Gloo Mesh will attempt to pull the image
	// and set it from the filter_conf contained in the image config.
	// note that if the filter_source is not set to wasm_image_source,
	// this field is required
	RootId string `protobuf:"bytes,5,opt,name=root_id,json=rootId,proto3" json:"root_id,omitempty"`
	// An ID which will be used along with a hash of the wasm code
	// (or the name of the registered Null VM plugin) to determine which VM will be used to load the WASM filter.
	// All filters on the same proxy which use the same vm_id and code within will use the same VM.
	// May be left blank. Sharing a VM between plugins can reduce memory utilization and make sharing of data easier which may have security implications.
	VmId string `protobuf:"bytes,6,opt,name=vm_id,json=vmId,proto3" json:"vm_id,omitempty"`
	// The specific config generation context to which to attach the filter. Istio
	// generates envoy configuration in the context of a gateway,
	// inbound traffic to sidecar and outbound traffic from sidecar.
	// Uses the Istio default (ANY).
	FilterContext v1alpha3.EnvoyFilter_PatchContext `protobuf:"varint,7,opt,name=filter_context,json=filterContext,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_PatchContext" json:"filter_context,omitempty"`
	// The filter in the Envoy HTTP Filter Chain immediately before which the WASM filter will be
	// inserted.
	// Defaults to `envoy.router`.
	InsertBeforeFilter   string   `protobuf:"bytes,9,opt,name=insert_before_filter,json=insertBeforeFilter,proto3" json:"insert_before_filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WasmFilterSpec) Reset()         { *m = WasmFilterSpec{} }
func (m *WasmFilterSpec) String() string { return proto.CompactTextString(m) }
func (*WasmFilterSpec) ProtoMessage()    {}
func (*WasmFilterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e51cfc9660b2e1a2, []int{1}
}

func (m *WasmFilterSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WasmFilterSpec.Unmarshal(m, b)
}
func (m *WasmFilterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WasmFilterSpec.Marshal(b, m, deterministic)
}
func (m *WasmFilterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WasmFilterSpec.Merge(m, src)
}
func (m *WasmFilterSpec) XXX_Size() int {
	return xxx_messageInfo_WasmFilterSpec.Size(m)
}
func (m *WasmFilterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WasmFilterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WasmFilterSpec proto.InternalMessageInfo

type isWasmFilterSpec_FilterSource interface {
	isWasmFilterSpec_FilterSource()
}

type WasmFilterSpec_LocalPathSource struct {
	LocalPathSource string `protobuf:"bytes,1,opt,name=local_path_source,json=localPathSource,proto3,oneof"`
}

type WasmFilterSpec_HttpUriSource struct {
	HttpUriSource *UriSource `protobuf:"bytes,2,opt,name=http_uri_source,json=httpUriSource,proto3,oneof"`
}

type WasmFilterSpec_WasmImageSource struct {
	WasmImageSource *WasmImageSource `protobuf:"bytes,3,opt,name=wasm_image_source,json=wasmImageSource,proto3,oneof"`
}

func (*WasmFilterSpec_LocalPathSource) isWasmFilterSpec_FilterSource() {}

func (*WasmFilterSpec_HttpUriSource) isWasmFilterSpec_FilterSource() {}

func (*WasmFilterSpec_WasmImageSource) isWasmFilterSpec_FilterSource() {}

func (m *WasmFilterSpec) GetFilterSource() isWasmFilterSpec_FilterSource {
	if m != nil {
		return m.FilterSource
	}
	return nil
}

func (m *WasmFilterSpec) GetLocalPathSource() string {
	if x, ok := m.GetFilterSource().(*WasmFilterSpec_LocalPathSource); ok {
		return x.LocalPathSource
	}
	return ""
}

func (m *WasmFilterSpec) GetHttpUriSource() *UriSource {
	if x, ok := m.GetFilterSource().(*WasmFilterSpec_HttpUriSource); ok {
		return x.HttpUriSource
	}
	return nil
}

func (m *WasmFilterSpec) GetWasmImageSource() *WasmImageSource {
	if x, ok := m.GetFilterSource().(*WasmFilterSpec_WasmImageSource); ok {
		return x.WasmImageSource
	}
	return nil
}

type isWasmFilterSpec_FilterConfigSource interface {
	isWasmFilterSpec_FilterConfigSource()
}

type WasmFilterSpec_StaticFilterConfig struct {
	StaticFilterConfig *any.Any `protobuf:"bytes,4,opt,name=static_filter_config,json=staticFilterConfig,proto3,oneof"`
}

type WasmFilterSpec_DynamicFilterConfig struct {
	DynamicFilterConfig string `protobuf:"bytes,8,opt,name=dynamic_filter_config,json=dynamicFilterConfig,proto3,oneof"`
}

func (*WasmFilterSpec_StaticFilterConfig) isWasmFilterSpec_FilterConfigSource() {}

func (*WasmFilterSpec_DynamicFilterConfig) isWasmFilterSpec_FilterConfigSource() {}

func (m *WasmFilterSpec) GetFilterConfigSource() isWasmFilterSpec_FilterConfigSource {
	if m != nil {
		return m.FilterConfigSource
	}
	return nil
}

func (m *WasmFilterSpec) GetStaticFilterConfig() *any.Any {
	if x, ok := m.GetFilterConfigSource().(*WasmFilterSpec_StaticFilterConfig); ok {
		return x.StaticFilterConfig
	}
	return nil
}

func (m *WasmFilterSpec) GetDynamicFilterConfig() string {
	if x, ok := m.GetFilterConfigSource().(*WasmFilterSpec_DynamicFilterConfig); ok {
		return x.DynamicFilterConfig
	}
	return ""
}

func (m *WasmFilterSpec) GetRootId() string {
	if m != nil {
		return m.RootId
	}
	return ""
}

func (m *WasmFilterSpec) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *WasmFilterSpec) GetFilterContext() v1alpha3.EnvoyFilter_PatchContext {
	if m != nil {
		return m.FilterContext
	}
	return v1alpha3.EnvoyFilter_ANY
}

func (m *WasmFilterSpec) GetInsertBeforeFilter() string {
	if m != nil {
		return m.InsertBeforeFilter
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WasmFilterSpec) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WasmFilterSpec_LocalPathSource)(nil),
		(*WasmFilterSpec_HttpUriSource)(nil),
		(*WasmFilterSpec_WasmImageSource)(nil),
		(*WasmFilterSpec_StaticFilterConfig)(nil),
		(*WasmFilterSpec_DynamicFilterConfig)(nil),
	}
}

// Specifies options for fetching WASM Filters from an HTTP URI.
type UriSource struct {
	// The HTTP URI from which to fetch the filter
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// The Sha256 Checksum of the filter binary (will be verified by the proxy).
	// Required.
	Sha                  string   `protobuf:"bytes,2,opt,name=sha,proto3" json:"sha,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UriSource) Reset()         { *m = UriSource{} }
func (m *UriSource) String() string { return proto.CompactTextString(m) }
func (*UriSource) ProtoMessage()    {}
func (*UriSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_e51cfc9660b2e1a2, []int{2}
}

func (m *UriSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UriSource.Unmarshal(m, b)
}
func (m *UriSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UriSource.Marshal(b, m, deterministic)
}
func (m *UriSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UriSource.Merge(m, src)
}
func (m *UriSource) XXX_Size() int {
	return xxx_messageInfo_UriSource.Size(m)
}
func (m *UriSource) XXX_DiscardUnknown() {
	xxx_messageInfo_UriSource.DiscardUnknown(m)
}

var xxx_messageInfo_UriSource proto.InternalMessageInfo

func (m *UriSource) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *UriSource) GetSha() string {
	if m != nil {
		return m.Sha
	}
	return ""
}

// Specifies options for fetching WASM Filters from a [WASM-compatible OCI Registry](https://webassemblyhub.io/)
// Images can be built and pushed to registries using `meshctl` and `wasme`.
type WasmImageSource struct {
	// the full tag of the wasm image. should include the registry address at the beginning, e.g. webassemblyhub.io/ilackarms/helloworld:v0.1
	WasmImageTag         string   `protobuf:"bytes,1,opt,name=wasm_image_tag,json=wasmImageTag,proto3" json:"wasm_image_tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WasmImageSource) Reset()         { *m = WasmImageSource{} }
func (m *WasmImageSource) String() string { return proto.CompactTextString(m) }
func (*WasmImageSource) ProtoMessage()    {}
func (*WasmImageSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_e51cfc9660b2e1a2, []int{3}
}

func (m *WasmImageSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WasmImageSource.Unmarshal(m, b)
}
func (m *WasmImageSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WasmImageSource.Marshal(b, m, deterministic)
}
func (m *WasmImageSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WasmImageSource.Merge(m, src)
}
func (m *WasmImageSource) XXX_Size() int {
	return xxx_messageInfo_WasmImageSource.Size(m)
}
func (m *WasmImageSource) XXX_DiscardUnknown() {
	xxx_messageInfo_WasmImageSource.DiscardUnknown(m)
}

var xxx_messageInfo_WasmImageSource proto.InternalMessageInfo

func (m *WasmImageSource) GetWasmImageTag() string {
	if m != nil {
		return m.WasmImageTag
	}
	return ""
}

// NOTE: ImagePullOptions are currently unsupported
type ImagePullOptions struct {
	// if a username/password is required,
	// specify here the name of a secret:
	// with keys:
	// * username: <username>
	// * password: <password>
	//
	// the secret must live in the WASM Cache Agent namespace
	// as the FilterDeployment
	PullSecret string `protobuf:"bytes,1,opt,name=pullSecret,proto3" json:"pullSecret,omitempty"`
	// skip verifying the image server's TLS certificate
	InsecureSkipVerify bool `protobuf:"varint,2,opt,name=insecureSkipVerify,proto3" json:"insecureSkipVerify,omitempty"`
	// use HTTP instead of HTTPS
	PlainHttp            bool     `protobuf:"varint,3,opt,name=plainHttp,proto3" json:"plainHttp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImagePullOptions) Reset()         { *m = ImagePullOptions{} }
func (m *ImagePullOptions) String() string { return proto.CompactTextString(m) }
func (*ImagePullOptions) ProtoMessage()    {}
func (*ImagePullOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e51cfc9660b2e1a2, []int{4}
}

func (m *ImagePullOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImagePullOptions.Unmarshal(m, b)
}
func (m *ImagePullOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImagePullOptions.Marshal(b, m, deterministic)
}
func (m *ImagePullOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImagePullOptions.Merge(m, src)
}
func (m *ImagePullOptions) XXX_Size() int {
	return xxx_messageInfo_ImagePullOptions.Size(m)
}
func (m *ImagePullOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ImagePullOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ImagePullOptions proto.InternalMessageInfo

func (m *ImagePullOptions) GetPullSecret() string {
	if m != nil {
		return m.PullSecret
	}
	return ""
}

func (m *ImagePullOptions) GetInsecureSkipVerify() bool {
	if m != nil {
		return m.InsecureSkipVerify
	}
	return false
}

func (m *ImagePullOptions) GetPlainHttp() bool {
	if m != nil {
		return m.PlainHttp
	}
	return false
}

type WasmDeploymentStatus struct {
	// The most recent generation observed in the the WasmDeployment metadata.
	// if the observedGeneration does not match generation, the controller has not received the most
	// recent version of this resource.
	ObservedGeneration int64 `protobuf:"varint,1,opt,name=observed_generation,json=observedGeneration,proto3" json:"observed_generation,omitempty"`
	// Any errors encountered while processing this generation of the resource.
	// This can include failures to pull a WASM image as well as missing or invalid
	// fields in the spec.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// the state of the WasmDeployment as it has been applied to each individual workload.
	WorkloadStates       map[string]WasmDeploymentStatus_WorkloadState `protobuf:"bytes,3,rep,name=workload_states,json=workloadStates,proto3" json:"workload_states,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=networking.enterprise.mesh.gloo.solo.io.WasmDeploymentStatus_WorkloadState"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *WasmDeploymentStatus) Reset()         { *m = WasmDeploymentStatus{} }
func (m *WasmDeploymentStatus) String() string { return proto.CompactTextString(m) }
func (*WasmDeploymentStatus) ProtoMessage()    {}
func (*WasmDeploymentStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_e51cfc9660b2e1a2, []int{5}
}

func (m *WasmDeploymentStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WasmDeploymentStatus.Unmarshal(m, b)
}
func (m *WasmDeploymentStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WasmDeploymentStatus.Marshal(b, m, deterministic)
}
func (m *WasmDeploymentStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WasmDeploymentStatus.Merge(m, src)
}
func (m *WasmDeploymentStatus) XXX_Size() int {
	return xxx_messageInfo_WasmDeploymentStatus.Size(m)
}
func (m *WasmDeploymentStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WasmDeploymentStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WasmDeploymentStatus proto.InternalMessageInfo

func (m *WasmDeploymentStatus) GetObservedGeneration() int64 {
	if m != nil {
		return m.ObservedGeneration
	}
	return 0
}

func (m *WasmDeploymentStatus) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *WasmDeploymentStatus) GetWorkloadStates() map[string]WasmDeploymentStatus_WorkloadState {
	if m != nil {
		return m.WorkloadStates
	}
	return nil
}

func init() {
	proto.RegisterEnum("networking.enterprise.mesh.gloo.solo.io.WasmDeploymentStatus_WorkloadState", WasmDeploymentStatus_WorkloadState_name, WasmDeploymentStatus_WorkloadState_value)
	proto.RegisterType((*WasmDeploymentSpec)(nil), "networking.enterprise.mesh.gloo.solo.io.WasmDeploymentSpec")
	proto.RegisterType((*WasmFilterSpec)(nil), "networking.enterprise.mesh.gloo.solo.io.WasmFilterSpec")
	proto.RegisterType((*UriSource)(nil), "networking.enterprise.mesh.gloo.solo.io.UriSource")
	proto.RegisterType((*WasmImageSource)(nil), "networking.enterprise.mesh.gloo.solo.io.WasmImageSource")
	proto.RegisterType((*ImagePullOptions)(nil), "networking.enterprise.mesh.gloo.solo.io.ImagePullOptions")
	proto.RegisterType((*WasmDeploymentStatus)(nil), "networking.enterprise.mesh.gloo.solo.io.WasmDeploymentStatus")
	proto.RegisterMapType((map[string]WasmDeploymentStatus_WorkloadState)(nil), "networking.enterprise.mesh.gloo.solo.io.WasmDeploymentStatus.WorkloadStatesEntry")
}

func init() {
	proto.RegisterFile("github.com/solo-io/gloo-mesh/api/enterprise/networking/v1alpha1/wasm_deployment.proto", fileDescriptor_e51cfc9660b2e1a2)
}

var fileDescriptor_e51cfc9660b2e1a2 = []byte{
	// 907 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x8e, 0xe2, 0xfc, 0xf9, 0x74, 0xb1, 0x1d, 0xc6, 0xcd, 0xbc, 0x60, 0x18, 0x0c, 0x63, 0xd8,
	0x7c, 0xb1, 0x52, 0x8b, 0x33, 0xa0, 0xc5, 0x6e, 0x86, 0xa6, 0x76, 0x6a, 0xa3, 0x59, 0xea, 0xca,
	0xe9, 0x82, 0x75, 0x03, 0x04, 0x5a, 0xa6, 0x65, 0xc2, 0xb2, 0x28, 0x90, 0x94, 0x3d, 0xef, 0x6a,
	0x4f, 0xb0, 0x67, 0xda, 0x83, 0xec, 0x05, 0xf6, 0x16, 0x03, 0x29, 0xc9, 0x7f, 0x09, 0xba, 0x36,
	0xd8, 0x95, 0xc4, 0xf3, 0xf3, 0xf1, 0x3b, 0xfc, 0x0e, 0x0f, 0xe1, 0xad, 0xcf, 0xd4, 0x28, 0xee,
	0x63, 0x8f, 0x4f, 0x6c, 0xc9, 0x03, 0xfe, 0x84, 0x71, 0xdb, 0x0f, 0x38, 0x7f, 0x32, 0xa1, 0x72,
	0x64, 0x93, 0x88, 0xd9, 0x34, 0x54, 0x54, 0x44, 0x82, 0x49, 0x6a, 0x87, 0x54, 0xcd, 0xb8, 0x18,
	0xb3, 0xd0, 0xb7, 0xa7, 0x67, 0x24, 0x88, 0x46, 0xe4, 0xcc, 0x9e, 0x11, 0x39, 0x71, 0x07, 0x34,
	0x0a, 0xf8, 0x7c, 0x42, 0x43, 0x85, 0x23, 0xc1, 0x15, 0x47, 0x5f, 0x2f, 0x43, 0xf1, 0x12, 0x00,
	0x6b, 0x50, 0xac, 0xe1, 0xb1, 0xde, 0x0b, 0x33, 0x7e, 0xfa, 0x99, 0xcf, 0xb9, 0x1f, 0x50, 0xdb,
	0xa4, 0xf5, 0xe3, 0xa1, 0x4d, 0xc2, 0x79, 0x82, 0x71, 0x8a, 0xef, 0xa1, 0x26, 0xc7, 0xd3, 0x86,
	0x61, 0xe5, 0x71, 0x41, 0xed, 0xe9, 0x99, 0xf9, 0xa6, 0xf1, 0x3f, 0xfc, 0x67, 0x29, 0x77, 0xf9,
	0x37, 0xec, 0x91, 0x52, 0x51, 0x0a, 0xd0, 0x7c, 0x10, 0x80, 0xa4, 0x01, 0xf5, 0x14, 0x17, 0x32,
	0x45, 0x79, 0xf5, 0x20, 0x94, 0x29, 0x09, 0xd8, 0x80, 0x28, 0xc6, 0x43, 0x57, 0x2a, 0xa2, 0xb2,
	0x9a, 0xbe, 0xba, 0x1b, 0x7b, 0x6e, 0xd3, 0x70, 0xca, 0xe7, 0xee, 0x90, 0x05, 0x8a, 0x8a, 0x24,
	0xae, 0xf6, 0xb7, 0x05, 0xe8, 0x96, 0xc8, 0x49, 0x73, 0x21, 0x44, 0x2f, 0xa2, 0x1e, 0xfa, 0x05,
	0x8e, 0x74, 0x76, 0xc0, 0xc9, 0xc0, 0xcd, 0x78, 0x56, 0xac, 0x6a, 0xae, 0xfe, 0xa8, 0x81, 0xf1,
	0x8a, 0x44, 0x77, 0x74, 0xc1, 0xb7, 0x69, 0x5a, 0x2f, 0xcd, 0x72, 0x4a, 0xb3, 0x0d, 0x0b, 0x7a,
	0x03, 0xfb, 0x09, 0x07, 0x59, 0xd9, 0x36, 0x90, 0x4f, 0xf1, 0x07, 0xaa, 0x8e, 0x35, 0xd5, 0x4b,
	0x93, 0xab, 0x69, 0x3a, 0x19, 0x0e, 0x3a, 0x81, 0xbd, 0x19, 0x65, 0xfe, 0x48, 0x55, 0x72, 0x55,
	0xab, 0x7e, 0xe8, 0xa4, 0xab, 0xda, 0x3f, 0x3b, 0x50, 0x58, 0xcf, 0x41, 0xdf, 0xc0, 0x51, 0xc0,
	0x3d, 0x12, 0xb8, 0x11, 0x51, 0x23, 0x57, 0xf2, 0x58, 0x78, 0xb4, 0x62, 0x55, 0xad, 0x7a, 0xbe,
	0xbd, 0xe5, 0x14, 0x8d, 0xab, 0x4b, 0xd4, 0xa8, 0x67, 0x1c, 0xe8, 0x57, 0x28, 0x6a, 0xa1, 0xdd,
	0x58, 0xb0, 0x2c, 0x76, 0xbb, 0x6a, 0xd5, 0x1f, 0x35, 0x1a, 0x1f, 0xcc, 0xf9, 0xad, 0x60, 0x09,
	0x58, 0x7b, 0xcb, 0x39, 0xd4, 0x60, 0x0b, 0x03, 0x1a, 0xc2, 0x91, 0xb9, 0x06, 0x6c, 0x42, 0x7c,
	0x9a, 0xe1, 0xe7, 0x0c, 0xfe, 0xb3, 0x8f, 0x3a, 0x93, 0x8e, 0x06, 0x58, 0xec, 0x52, 0x9c, 0xad,
	0x9b, 0x50, 0x1b, 0xca, 0xba, 0x39, 0x98, 0x97, 0x8a, 0xef, 0x7a, 0x3c, 0x1c, 0x32, 0xbf, 0xb2,
	0x63, 0xb6, 0x2a, 0xe3, 0xe4, 0x2e, 0xe1, 0xec, 0x2e, 0xe1, 0xe7, 0xe1, 0xbc, 0x6d, 0x39, 0x28,
	0xc9, 0x49, 0xce, 0xee, 0x85, 0xc9, 0x40, 0xdf, 0xc1, 0xe3, 0xc1, 0x3c, 0x24, 0x93, 0x3b, 0x50,
	0x07, 0xe6, 0x04, 0x2d, 0xe7, 0x38, 0x75, 0xaf, 0x65, 0x7d, 0x0a, 0xfb, 0x82, 0x73, 0xe5, 0xb2,
	0x41, 0x65, 0x57, 0xc7, 0x39, 0x7b, 0x7a, 0xd9, 0x19, 0xa0, 0x63, 0xd8, 0x9d, 0x4e, 0xb4, 0x79,
	0xcf, 0x98, 0x77, 0xa6, 0x93, 0xce, 0x00, 0xbd, 0x83, 0xc2, 0x12, 0x5b, 0xd1, 0xdf, 0x54, 0x65,
	0xbf, 0x6a, 0xd5, 0x0b, 0x8d, 0x73, 0xcc, 0xa4, 0x62, 0x7c, 0xf5, 0x60, 0xb2, 0xd6, 0xc6, 0x2d,
	0xdd, 0xda, 0xc9, 0x9e, 0xb8, 0x4b, 0x94, 0x37, 0x7a, 0x91, 0xa4, 0x3a, 0x87, 0xc3, 0x8c, 0x88,
	0x5e, 0xa2, 0x6f, 0xa1, 0xcc, 0x42, 0x49, 0x85, 0x72, 0xfb, 0x74, 0xc8, 0x05, 0x4d, 0xab, 0xa8,
	0xe4, 0xcd, 0xfe, 0x28, 0xf1, 0x5d, 0x18, 0x57, 0x82, 0x76, 0x51, 0x84, 0x14, 0x22, 0xd5, 0xe7,
	0xe2, 0x04, 0xca, 0x6b, 0xa5, 0xa7, 0xf6, 0x9a, 0x0d, 0xf9, 0xa5, 0xb2, 0x25, 0xc8, 0xc5, 0x82,
	0x25, 0x7d, 0xe5, 0xe8, 0x5f, 0x6d, 0x91, 0x23, 0x62, 0xba, 0x27, 0xef, 0xe8, 0xdf, 0xda, 0x53,
	0x28, 0x6e, 0x68, 0x87, 0xbe, 0x84, 0xc2, 0x4a, 0x43, 0x28, 0xe2, 0xa7, 0x08, 0x9f, 0x2c, 0x14,
	0xbd, 0x21, 0x7e, 0xed, 0x0f, 0x0b, 0x4a, 0x66, 0xd1, 0x8d, 0x83, 0xe0, 0x75, 0xa4, 0x2f, 0xbf,
	0x44, 0x5f, 0x00, 0x44, 0x71, 0x10, 0xf4, 0xa8, 0x27, 0xa8, 0x4a, 0xd3, 0x56, 0x2c, 0x08, 0x83,
	0xa9, 0xce, 0x8b, 0x05, 0xed, 0x8d, 0x59, 0xf4, 0x13, 0x15, 0x6c, 0x38, 0x37, 0x74, 0x0e, 0x9c,
	0x7b, 0x3c, 0xe8, 0x73, 0xc8, 0x47, 0x01, 0x61, 0x61, 0x5b, 0xa9, 0xc8, 0xf4, 0xe4, 0x81, 0xb3,
	0x34, 0xd4, 0xfe, 0xca, 0x41, 0x79, 0x63, 0x6e, 0x28, 0xa2, 0x62, 0x89, 0x6c, 0x38, 0xe6, 0x7d,
	0x49, 0xc5, 0x94, 0x0e, 0x5c, 0x9f, 0x86, 0x54, 0x98, 0xd9, 0x64, 0xf8, 0xe4, 0x1c, 0x94, 0xb9,
	0x5e, 0x2e, 0x3c, 0xa8, 0x0c, 0xbb, 0x54, 0x08, 0x2e, 0xd2, 0x93, 0x49, 0x16, 0xe8, 0x77, 0x28,
	0x2e, 0x07, 0x90, 0x9e, 0x6b, 0xb2, 0x92, 0x33, 0xb3, 0xe2, 0xcd, 0x47, 0xdd, 0x8b, 0x4d, 0x7a,
	0xcb, 0xf1, 0x64, 0x30, 0x5b, 0xa1, 0x12, 0x73, 0xa7, 0x30, 0x5b, 0x33, 0x9e, 0xfe, 0x69, 0xc1,
	0xf1, 0x3d, 0x71, 0x5a, 0xc1, 0x31, 0x9d, 0x67, 0x9a, 0x8e, 0xe9, 0x1c, 0x11, 0xd8, 0x9d, 0x92,
	0x20, 0x4e, 0x66, 0x42, 0xa1, 0xf1, 0xea, 0x7f, 0xe4, 0xe6, 0x24, 0xc8, 0xdf, 0x6f, 0x3f, 0xb3,
	0x6a, 0x37, 0x70, 0xb8, 0xe6, 0x43, 0x27, 0x80, 0x9a, 0xad, 0xee, 0xd5, 0xeb, 0x9f, 0x7f, 0x6c,
	0x5d, 0xdf, 0xb8, 0xdd, 0xd6, 0x75, 0xb3, 0x73, 0xfd, 0xb2, 0xb4, 0x85, 0xca, 0x50, 0xba, 0xec,
	0x5c, 0xdd, 0xb4, 0x9c, 0x9e, 0x9b, 0xf8, 0x5b, 0xcd, 0x92, 0x85, 0x1e, 0xc3, 0xd1, 0x4a, 0xf4,
	0xe5, 0xf3, 0xce, 0x55, 0xab, 0x59, 0xda, 0xbe, 0xb8, 0x7d, 0xf7, 0xfe, 0x37, 0x3c, 0x1a, 0xfb,
	0x1b, 0xaf, 0xce, 0x7b, 0x6b, 0x5a, 0xbc, 0xec, 0xfd, 0x3d, 0x33, 0x47, 0xce, 0xff, 0x0d, 0x00,
	0x00, 0xff, 0xff, 0x7b, 0x23, 0xd1, 0xe8, 0x23, 0x08, 0x00, 0x00,
}
