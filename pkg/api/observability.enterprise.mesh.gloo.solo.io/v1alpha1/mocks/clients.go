// Code generated by MockGen. DO NOT EDIT.
// Source: ./clients.go

// Package mock_v1alpha1 is a generated GoMock package.
package mock_v1alpha1

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1alpha1"
	client "sigs.k8s.io/controller-runtime/pkg/client"
)

// MockMulticlusterClientset is a mock of MulticlusterClientset interface
type MockMulticlusterClientset struct {
	ctrl     *gomock.Controller
	recorder *MockMulticlusterClientsetMockRecorder
}

// MockMulticlusterClientsetMockRecorder is the mock recorder for MockMulticlusterClientset
type MockMulticlusterClientsetMockRecorder struct {
	mock *MockMulticlusterClientset
}

// NewMockMulticlusterClientset creates a new mock instance
func NewMockMulticlusterClientset(ctrl *gomock.Controller) *MockMulticlusterClientset {
	mock := &MockMulticlusterClientset{ctrl: ctrl}
	mock.recorder = &MockMulticlusterClientsetMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMulticlusterClientset) EXPECT() *MockMulticlusterClientsetMockRecorder {
	return m.recorder
}

// Cluster mocks base method
func (m *MockMulticlusterClientset) Cluster(cluster string) (v1alpha1.Clientset, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster", cluster)
	ret0, _ := ret[0].(v1alpha1.Clientset)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Cluster indicates an expected call of Cluster
func (mr *MockMulticlusterClientsetMockRecorder) Cluster(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockMulticlusterClientset)(nil).Cluster), cluster)
}

// MockClientset is a mock of Clientset interface
type MockClientset struct {
	ctrl     *gomock.Controller
	recorder *MockClientsetMockRecorder
}

// MockClientsetMockRecorder is the mock recorder for MockClientset
type MockClientsetMockRecorder struct {
	mock *MockClientset
}

// NewMockClientset creates a new mock instance
func NewMockClientset(ctrl *gomock.Controller) *MockClientset {
	mock := &MockClientset{ctrl: ctrl}
	mock.recorder = &MockClientsetMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockClientset) EXPECT() *MockClientsetMockRecorder {
	return m.recorder
}

// AccessLogCollections mocks base method
func (m *MockClientset) AccessLogCollections() v1alpha1.AccessLogCollectionClient {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AccessLogCollections")
	ret0, _ := ret[0].(v1alpha1.AccessLogCollectionClient)
	return ret0
}

// AccessLogCollections indicates an expected call of AccessLogCollections
func (mr *MockClientsetMockRecorder) AccessLogCollections() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AccessLogCollections", reflect.TypeOf((*MockClientset)(nil).AccessLogCollections))
}

// MockAccessLogCollectionReader is a mock of AccessLogCollectionReader interface
type MockAccessLogCollectionReader struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogCollectionReaderMockRecorder
}

// MockAccessLogCollectionReaderMockRecorder is the mock recorder for MockAccessLogCollectionReader
type MockAccessLogCollectionReaderMockRecorder struct {
	mock *MockAccessLogCollectionReader
}

// NewMockAccessLogCollectionReader creates a new mock instance
func NewMockAccessLogCollectionReader(ctrl *gomock.Controller) *MockAccessLogCollectionReader {
	mock := &MockAccessLogCollectionReader{ctrl: ctrl}
	mock.recorder = &MockAccessLogCollectionReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessLogCollectionReader) EXPECT() *MockAccessLogCollectionReaderMockRecorder {
	return m.recorder
}

// GetAccessLogCollection mocks base method
func (m *MockAccessLogCollectionReader) GetAccessLogCollection(ctx context.Context, key client.ObjectKey) (*v1alpha1.AccessLogCollection, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccessLogCollection", ctx, key)
	ret0, _ := ret[0].(*v1alpha1.AccessLogCollection)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccessLogCollection indicates an expected call of GetAccessLogCollection
func (mr *MockAccessLogCollectionReaderMockRecorder) GetAccessLogCollection(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionReader)(nil).GetAccessLogCollection), ctx, key)
}

// ListAccessLogCollection mocks base method
func (m *MockAccessLogCollectionReader) ListAccessLogCollection(ctx context.Context, opts ...client.ListOption) (*v1alpha1.AccessLogCollectionList, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAccessLogCollection", varargs...)
	ret0, _ := ret[0].(*v1alpha1.AccessLogCollectionList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccessLogCollection indicates an expected call of ListAccessLogCollection
func (mr *MockAccessLogCollectionReaderMockRecorder) ListAccessLogCollection(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionReader)(nil).ListAccessLogCollection), varargs...)
}

// MockAccessLogCollectionWriter is a mock of AccessLogCollectionWriter interface
type MockAccessLogCollectionWriter struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogCollectionWriterMockRecorder
}

// MockAccessLogCollectionWriterMockRecorder is the mock recorder for MockAccessLogCollectionWriter
type MockAccessLogCollectionWriterMockRecorder struct {
	mock *MockAccessLogCollectionWriter
}

// NewMockAccessLogCollectionWriter creates a new mock instance
func NewMockAccessLogCollectionWriter(ctrl *gomock.Controller) *MockAccessLogCollectionWriter {
	mock := &MockAccessLogCollectionWriter{ctrl: ctrl}
	mock.recorder = &MockAccessLogCollectionWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessLogCollectionWriter) EXPECT() *MockAccessLogCollectionWriterMockRecorder {
	return m.recorder
}

// CreateAccessLogCollection mocks base method
func (m *MockAccessLogCollectionWriter) CreateAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, opts ...client.CreateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateAccessLogCollection indicates an expected call of CreateAccessLogCollection
func (mr *MockAccessLogCollectionWriterMockRecorder) CreateAccessLogCollection(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionWriter)(nil).CreateAccessLogCollection), varargs...)
}

// DeleteAccessLogCollection mocks base method
func (m *MockAccessLogCollectionWriter) DeleteAccessLogCollection(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAccessLogCollection indicates an expected call of DeleteAccessLogCollection
func (mr *MockAccessLogCollectionWriterMockRecorder) DeleteAccessLogCollection(ctx, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionWriter)(nil).DeleteAccessLogCollection), varargs...)
}

// UpdateAccessLogCollection mocks base method
func (m *MockAccessLogCollectionWriter) UpdateAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogCollection indicates an expected call of UpdateAccessLogCollection
func (mr *MockAccessLogCollectionWriterMockRecorder) UpdateAccessLogCollection(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionWriter)(nil).UpdateAccessLogCollection), varargs...)
}

// PatchAccessLogCollection mocks base method
func (m *MockAccessLogCollectionWriter) PatchAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogCollection indicates an expected call of PatchAccessLogCollection
func (mr *MockAccessLogCollectionWriterMockRecorder) PatchAccessLogCollection(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionWriter)(nil).PatchAccessLogCollection), varargs...)
}

// DeleteAllOfAccessLogCollection mocks base method
func (m *MockAccessLogCollectionWriter) DeleteAllOfAccessLogCollection(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAllOfAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAllOfAccessLogCollection indicates an expected call of DeleteAllOfAccessLogCollection
func (mr *MockAccessLogCollectionWriterMockRecorder) DeleteAllOfAccessLogCollection(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllOfAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionWriter)(nil).DeleteAllOfAccessLogCollection), varargs...)
}

// UpsertAccessLogCollection mocks base method
func (m *MockAccessLogCollectionWriter) UpsertAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, transitionFuncs ...v1alpha1.AccessLogCollectionTransitionFunction) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range transitionFuncs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpsertAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertAccessLogCollection indicates an expected call of UpsertAccessLogCollection
func (mr *MockAccessLogCollectionWriterMockRecorder) UpsertAccessLogCollection(ctx, obj interface{}, transitionFuncs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, transitionFuncs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionWriter)(nil).UpsertAccessLogCollection), varargs...)
}

// MockAccessLogCollectionStatusWriter is a mock of AccessLogCollectionStatusWriter interface
type MockAccessLogCollectionStatusWriter struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogCollectionStatusWriterMockRecorder
}

// MockAccessLogCollectionStatusWriterMockRecorder is the mock recorder for MockAccessLogCollectionStatusWriter
type MockAccessLogCollectionStatusWriterMockRecorder struct {
	mock *MockAccessLogCollectionStatusWriter
}

// NewMockAccessLogCollectionStatusWriter creates a new mock instance
func NewMockAccessLogCollectionStatusWriter(ctrl *gomock.Controller) *MockAccessLogCollectionStatusWriter {
	mock := &MockAccessLogCollectionStatusWriter{ctrl: ctrl}
	mock.recorder = &MockAccessLogCollectionStatusWriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessLogCollectionStatusWriter) EXPECT() *MockAccessLogCollectionStatusWriterMockRecorder {
	return m.recorder
}

// UpdateAccessLogCollectionStatus mocks base method
func (m *MockAccessLogCollectionStatusWriter) UpdateAccessLogCollectionStatus(ctx context.Context, obj *v1alpha1.AccessLogCollection, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogCollectionStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogCollectionStatus indicates an expected call of UpdateAccessLogCollectionStatus
func (mr *MockAccessLogCollectionStatusWriterMockRecorder) UpdateAccessLogCollectionStatus(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogCollectionStatus", reflect.TypeOf((*MockAccessLogCollectionStatusWriter)(nil).UpdateAccessLogCollectionStatus), varargs...)
}

// PatchAccessLogCollectionStatus mocks base method
func (m *MockAccessLogCollectionStatusWriter) PatchAccessLogCollectionStatus(ctx context.Context, obj *v1alpha1.AccessLogCollection, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogCollectionStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogCollectionStatus indicates an expected call of PatchAccessLogCollectionStatus
func (mr *MockAccessLogCollectionStatusWriterMockRecorder) PatchAccessLogCollectionStatus(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogCollectionStatus", reflect.TypeOf((*MockAccessLogCollectionStatusWriter)(nil).PatchAccessLogCollectionStatus), varargs...)
}

// MockAccessLogCollectionClient is a mock of AccessLogCollectionClient interface
type MockAccessLogCollectionClient struct {
	ctrl     *gomock.Controller
	recorder *MockAccessLogCollectionClientMockRecorder
}

// MockAccessLogCollectionClientMockRecorder is the mock recorder for MockAccessLogCollectionClient
type MockAccessLogCollectionClientMockRecorder struct {
	mock *MockAccessLogCollectionClient
}

// NewMockAccessLogCollectionClient creates a new mock instance
func NewMockAccessLogCollectionClient(ctrl *gomock.Controller) *MockAccessLogCollectionClient {
	mock := &MockAccessLogCollectionClient{ctrl: ctrl}
	mock.recorder = &MockAccessLogCollectionClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessLogCollectionClient) EXPECT() *MockAccessLogCollectionClientMockRecorder {
	return m.recorder
}

// GetAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) GetAccessLogCollection(ctx context.Context, key client.ObjectKey) (*v1alpha1.AccessLogCollection, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccessLogCollection", ctx, key)
	ret0, _ := ret[0].(*v1alpha1.AccessLogCollection)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccessLogCollection indicates an expected call of GetAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) GetAccessLogCollection(ctx, key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).GetAccessLogCollection), ctx, key)
}

// ListAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) ListAccessLogCollection(ctx context.Context, opts ...client.ListOption) (*v1alpha1.AccessLogCollectionList, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAccessLogCollection", varargs...)
	ret0, _ := ret[0].(*v1alpha1.AccessLogCollectionList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccessLogCollection indicates an expected call of ListAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) ListAccessLogCollection(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).ListAccessLogCollection), varargs...)
}

// CreateAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) CreateAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, opts ...client.CreateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateAccessLogCollection indicates an expected call of CreateAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) CreateAccessLogCollection(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).CreateAccessLogCollection), varargs...)
}

// DeleteAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) DeleteAccessLogCollection(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, key}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAccessLogCollection indicates an expected call of DeleteAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) DeleteAccessLogCollection(ctx, key interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, key}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).DeleteAccessLogCollection), varargs...)
}

// UpdateAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) UpdateAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogCollection indicates an expected call of UpdateAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) UpdateAccessLogCollection(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).UpdateAccessLogCollection), varargs...)
}

// PatchAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) PatchAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogCollection indicates an expected call of PatchAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) PatchAccessLogCollection(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).PatchAccessLogCollection), varargs...)
}

// DeleteAllOfAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) DeleteAllOfAccessLogCollection(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAllOfAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAllOfAccessLogCollection indicates an expected call of DeleteAllOfAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) DeleteAllOfAccessLogCollection(ctx interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllOfAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).DeleteAllOfAccessLogCollection), varargs...)
}

// UpsertAccessLogCollection mocks base method
func (m *MockAccessLogCollectionClient) UpsertAccessLogCollection(ctx context.Context, obj *v1alpha1.AccessLogCollection, transitionFuncs ...v1alpha1.AccessLogCollectionTransitionFunction) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range transitionFuncs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpsertAccessLogCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertAccessLogCollection indicates an expected call of UpsertAccessLogCollection
func (mr *MockAccessLogCollectionClientMockRecorder) UpsertAccessLogCollection(ctx, obj interface{}, transitionFuncs ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, transitionFuncs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertAccessLogCollection", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).UpsertAccessLogCollection), varargs...)
}

// UpdateAccessLogCollectionStatus mocks base method
func (m *MockAccessLogCollectionClient) UpdateAccessLogCollectionStatus(ctx context.Context, obj *v1alpha1.AccessLogCollection, opts ...client.UpdateOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAccessLogCollectionStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccessLogCollectionStatus indicates an expected call of UpdateAccessLogCollectionStatus
func (mr *MockAccessLogCollectionClientMockRecorder) UpdateAccessLogCollectionStatus(ctx, obj interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccessLogCollectionStatus", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).UpdateAccessLogCollectionStatus), varargs...)
}

// PatchAccessLogCollectionStatus mocks base method
func (m *MockAccessLogCollectionClient) PatchAccessLogCollectionStatus(ctx context.Context, obj *v1alpha1.AccessLogCollection, patch client.Patch, opts ...client.PatchOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, obj, patch}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PatchAccessLogCollectionStatus", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// PatchAccessLogCollectionStatus indicates an expected call of PatchAccessLogCollectionStatus
func (mr *MockAccessLogCollectionClientMockRecorder) PatchAccessLogCollectionStatus(ctx, obj, patch interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, obj, patch}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchAccessLogCollectionStatus", reflect.TypeOf((*MockAccessLogCollectionClient)(nil).PatchAccessLogCollectionStatus), varargs...)
}

// MockMulticlusterAccessLogCollectionClient is a mock of MulticlusterAccessLogCollectionClient interface
type MockMulticlusterAccessLogCollectionClient struct {
	ctrl     *gomock.Controller
	recorder *MockMulticlusterAccessLogCollectionClientMockRecorder
}

// MockMulticlusterAccessLogCollectionClientMockRecorder is the mock recorder for MockMulticlusterAccessLogCollectionClient
type MockMulticlusterAccessLogCollectionClientMockRecorder struct {
	mock *MockMulticlusterAccessLogCollectionClient
}

// NewMockMulticlusterAccessLogCollectionClient creates a new mock instance
func NewMockMulticlusterAccessLogCollectionClient(ctrl *gomock.Controller) *MockMulticlusterAccessLogCollectionClient {
	mock := &MockMulticlusterAccessLogCollectionClient{ctrl: ctrl}
	mock.recorder = &MockMulticlusterAccessLogCollectionClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMulticlusterAccessLogCollectionClient) EXPECT() *MockMulticlusterAccessLogCollectionClientMockRecorder {
	return m.recorder
}

// Cluster mocks base method
func (m *MockMulticlusterAccessLogCollectionClient) Cluster(cluster string) (v1alpha1.AccessLogCollectionClient, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cluster", cluster)
	ret0, _ := ret[0].(v1alpha1.AccessLogCollectionClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Cluster indicates an expected call of Cluster
func (mr *MockMulticlusterAccessLogCollectionClientMockRecorder) Cluster(cluster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cluster", reflect.TypeOf((*MockMulticlusterAccessLogCollectionClient)(nil).Cluster), cluster)
}
