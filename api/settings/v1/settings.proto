syntax = "proto3";
package settings.mesh.gloo.solo.io;
option go_package = "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1";

import "extproto/ext.proto";
option (extproto.equal_all) = true;

import "github.com/solo-io/gloo-mesh/api/common/v1/validation_state.proto";
import "github.com/solo-io/gloo-mesh/api/networking/v1/traffic_policy.proto";
import "github.com/solo-io/skv2/api/core/v1/core.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

// Configure system-wide settings and defaults. Settings specified in networking policies take precedence over those specified here.
message SettingsSpec {

    // Configure default mTLS settings for Destinations.
    .networking.mesh.gloo.solo.io.TrafficPolicySpec.Policy.MTLS mtls = 1;

    // Configure Gloo Mesh networking to communicate with one or more external gRPC NetworkingExtensions servers.
    // Updates will be applied by the servers in the order they are listed (servers towards the end of the list take precedence).
    // Note: Extension Servers have full write access to the output objects written by Gloo Mesh.
    repeated GrpcServer networking_extension_servers = 2;

    // Settings for Gloo Mesh discovery.
    DiscoverySettings discovery = 3;

    // Enable and configure use of Relay mode to communicate with remote clusters. This is an enterprise-only feature.
    RelaySettings relay = 4;

    // Configure the enterprise dashboard.
    DashboardSettings dashboard = 5;
}

// RelaySettings contains options for configuring Gloo Mesh to use Relay for cluster management.
// Relay provides a way for connecting Gloo Mesh to remote Kubernetes Clusters
// without the need to share credentials and access to remote Kube API Servers
// from the management cluster (the Gloo Mesh controllers).
//
// Relay instead uses a streaming gRPC API to pass discovery data
// from remote clusters to the management cluster, and push
// configuration from the management cluster to the remote clusters.
//
// Architecturally, it includes a Relay-agent which is installed to remote Kube clusters at
// registration time, which then connects directly to the Relay Server in the management cluster.
// to push its discovery data and pull its mesh configuration.
//
//
// To configure Gloo Mesh to use Relay, make sure to read the
// [relay installation guide]({{< versioned_link_path fromRoot="/guides/setup/install_gloo_mesh" >}}) and
// [relay cluster registration guide]({{< versioned_link_path fromRoot="/guides/setup/register_cluster" >}}).
message RelaySettings {

    // Enable the use of Relay for cluster management.
    // If relay is enabled, make sure to follow the [relay cluster registration guide]({{< versioned_link_path fromRoot="/guides/setup/register_cluster#relay" >}})
    // for registering your clusters.
    bool enabled = 1;

    // Connection info for the Relay Server. Gloo Mesh will fetch discovery resources from this server
    // and push translated outputs to this server.
    // Note: currently this field has no effect as the relay server runs in-process of the networking Pod.
    GrpcServer server = 2;
}

// Settings for Gloo Mesh discovery.
message DiscoverySettings {

    // Istio-specific discovery settings
    Istio istio = 1;

    // Istio-specific discovery settings
    message Istio {

        // Configure discovery of ingress gateways per cluster. The key to the map is either a Gloo Mesh cluster name or
        // `*` denoting all clusters. If an entry is found for a given cluster, it will be used. Otherwise, the
        // wildcard entry will be used if it exists. Lastly, we will fall back to a set of default values.
        map<string, IngressGatewayDetector> ingress_gateway_detectors = 1;

        // Configure discovery of ingress gateways.
        message IngressGatewayDetector {

            // Workload labels used to detect ingress gateways for an Istio deployment.
            // If not specified, will default to `{"istio": "ingressgateway"}`.
            map<string, string> gateway_workload_labels = 1;

            // The name of the TLS port used to detect ingress gateways. Kubernetes services must have a port with this name
            // in order to be recognized as an ingress gateway. If not specified, will default to `tls`.
            string gateway_tls_port_name = 2;
        }
    }
}

// Options for connecting to an external gRPC server.
message GrpcServer {

    // TCP address of the gRPC Server (including port).
    string address = 1;

    // If true communicate over HTTP rather than HTTPS.
    bool insecure = 2;

    // If true Gloo Mesh will automatically attempt to reconnect to the server after encountering network failures.
    bool reconnect_on_network_failures = 3;
}

message DashboardSettings {
    message AuthConfig {
        google.protobuf.StringValue name = 1;

        oneof auth_config {
            OidcConfig oidc = 2;
        }
    }

    repeated AuthConfig auth_configs = 1;
}

message SessionConfig {
    message CookieSession {}

    message RedisSession {}

    message CookieOptions {
        // Max age of the cookie. If unset, the default of 30 days will be
        // used. To disable expiration, set explicitly to 0.
        google.protobuf.UInt32Value max_age = 1;

        // Use an insecure cookie.
        // Should only be used for testing and in trusted environments.
        bool not_secure = 2;

        // Path of the cookie. Defaults to "/", set to "" to disable the
        // option.
        google.protobuf.StringValue path = 3;

        // Domain of the cookie.
        string domain = 4;
    }

    // Set-Cookie options
    CookieOptions cookie_options = 1;

    oneof backend {
        // Store all session data in the cookie itself
        CookieSession cookie = 2;

        // Store the session data in a Redis instance.
        RedisSession redis = 3;
    }
}

message OidcConfig {
    // The client ID from the issuer
    string client_id = 1;

    // THe client secret from the issuer
    core.skv2.solo.io.ObjectRef client_secret = 2;

    // The url of the issuer. We will look for OIDC information in:
    //   {{ issuerURL }}/.well-known/openid-configuration
    string issuer_url = 3;

    // Extra query parameters to apply to the authorization request to the
    // identity provider. For example, using the PKCE flow
    // (https://www.oauth.com/oauth2-servers/pkce/authorization-request/) by
    // setting `code_challenge` and `code_challenge_method`.
    map<string, string> auth_endpoint_query_params = 4;

    // Extra query parameters to apply to the token request to the identity
    // provider. For example, using the PKCE flow
    // (https://www.oauth.com/oauth2-servers/pkce/authorization-request/) by
    // setting `code_challenge` and `code_challenge_method`.
    map<string, string> token_endpoint_query_params = 5;

    // URL to redirect to after successful auth.
    string app_url = 6;

    // Path to handle the OIDC callback.
    string callback_path = 7;

    // Path used to logout. If not provided, logout will be disabled.
    string logout_path = 8;

    // Scopes to request in addition to 'openid'.
    repeated string scopes = 9;

    message HeaderConfig {
        // If set, the ID token will be sent upstream with this header.
        string id_token_header = 1;

        // If set, the access token will be sent upstream with this header.
        string access_token_header = 2;
    }

    // Additional headers.
    HeaderConfig header = 10;

    // OIDC configuration is discovered at
    // <issuerUrl>/.well-known/openid-configuration The discovery override
    // defines any properties that should override this discovery
    // configuration
    // https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
    message DiscoveryOverride {
        // URL of the provider authorization endpoint.
        string auth_endpoint = 1;

        // URL of the provider token endpoint.
        string token_endpoint = 2;

        // URL of the provider JSON web key set.
        string jwks_uri = 3;

        // List of scope values that the provider supports.
        repeated string scopes = 4;

        // List of response types that the provider supports.
        repeated string response_types = 5;

        // List of subject identifier types that the provider supports.
        repeated string subjects = 6;

        // List of json web signature signing algorithms that the provider
        // supports for encoding claims in a JWT.
        repeated string id_token_algs = 7;

        // List of client authentication methods supported by the provider
        // token endpoint.
        repeated string auth_methods = 8;

        // List of claim types that the provider supports.
        repeated string claims = 9;
    }

    // Ensure that certain values are set regardless of what the OIDC
    // provider returns.
    DiscoveryOverride discovery_override = 11;

    // How often to poll the OIDC issuer for new configuration.
    google.protobuf.Duration discovery_poll_interval = 12;

    // If a user executes a request with a key that is not found in the
    // JWKS, it could be that the keys have rotated on the remote source,
    // and not yet in the local cache. This policy lets you define the
    // behavior for how to refresh the local cache during a request where an
    // invalid key is provided
    JwksOnDemandCacheRefreshPolicy jwks_cache_refresh_policy = 13;
}

// The json web key set (JWKS) (https://tools.ietf.org/html/rfc7517) is
// discovered at an interval from a remote source. When keys rotate in
// the remote source, there may be a delay in the local source picking
// up those new keys. Therefore, a user could execute a request with a
// token that has been signed by a key in the remote JWKS, but the local
// cache doesn't have the key yet. The request would fail because the
// key isn't contained in the local set. Since most IdPs publish key
// keys in their remote JWKS before they are used, this is not an issue
// most of the time. This policy lets you define the behavior for when a
// user has a token with a key not yet in the local cache.
message JwksOnDemandCacheRefreshPolicy {
    oneof policy {
        // Never refresh the local JWKS cache on demand. If a key is not
        // in the cache, it is assumed to be malicious. This is the
        // default policy since we assume that IdPs publish keys before
        // they rotate them, and frequent polling finds the newest keys.
        google.protobuf.Empty never = 1;

        // If a key is not in the cache, fetch the most recent keys from
        // the IdP and update the cache. NOTE: This should only be done
        // in trusted environments, since missing keys will each trigger
        // a request to the IdP. Using this in an environment exposed to
        // the internet will allow malicious agents to execute a DDoS
        // attack by spamming protected endpoints with tokens signed by
        // invalid keys.
        google.protobuf.Empty always = 2;

        // If a key is not in the cache, fetch the most recent keys from
        // the IdP and update the cache. This value sets the number of
        // requests to the IdP per polling interval. If that limit is
        // exceeded, we will stop fetching from the IdP for the
        // remainder of the polling interval.
        uint32 max_idp_req_per_polling_interval = 3;
    }
}

message SettingsStatus {

    // The most recent generation observed in the the Settings metadata.
    // If the `observedGeneration` does not match `metadata.generation`, Gloo Mesh has not processed the most
    // recent version of this resource.
    int64 observed_generation = 1;

    // The state of the overall resource.
    // It will only show accepted if no processing errors encountered.
    .common.mesh.gloo.solo.io.ApprovalState state = 2;

    // Any errors encountered while processing Settings object.
    repeated string errors = 3;
}
