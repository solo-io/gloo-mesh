syntax = "proto3";
package networking.mesh.gloo.solo.io;
option go_package = "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1";

import "github.com/solo-io/gloo-mesh/api/common/v1/refs.proto";

import "google/protobuf/wrappers.proto";
import "google/protobuf/duration.proto";

import "extproto/ext.proto";
option (extproto.equal_all) = true;

import "google/protobuf/struct.proto";

import "github.com/solo-io/skv2/api/core/v1/core.proto";

message RouteRateLimit {

    oneof rate_limit_config_type {

        // Config for rate-limiting using simplified (gloo-specific) API
        BasicRateLimit basic = 1;

        // Partial config for GlooE rate-limiting based on Envoy's rate-limit service;
        // supports Envoy's rate-limit service API. (reference here: https://github.com/lyft/ratelimit#configuration)
        // Configure rate-limit *actions* here, which define how request characteristics get translated into
        // descriptors used by the rate-limit service for rate-limiting. Configure rate-limit *descriptors* and
        // their associated limits on the Gloo settings.
        // Only one of `ratelimit` or `rate_limit_configs` can be set.
        AdvancedRateLimit advanced = 2;

        // References to RateLimitConfig resources. This is used to configure the GlooE rate limit server.
        // Only one of `ratelimit` or `rate_limit_configs` can be set.
        .common.mesh.gloo.solo.io.ObjectRefList config_refs = 3;
    }

    // Basic rate-limiting API
    message BasicRateLimit {
        // limits for authorized users
        RequestLimit authorized_limits = 1;
        // limits for unauthorized users
        RequestLimit anonymous_limits = 2;
    }

    // Use this field if you want to inline the Envoy rate limits for this VirtualHost.
    // Note that this does not configure the rate limit server. If you are running Gloo Enterprise, you need to
    // specify the server configuration via the appropriate field in the Gloo `Settings` resource. If you are
    // running a custom rate limit server you need to configure it yourself.
    message AdvancedRateLimit {

        // Define individual rate limits here. Each rate limit will be evaluated, if any rate limit
        // would be throttled, the entire request returns a 429 (gets throttled)
        repeated RateLimitActions actions = 1;

    }
}

// Use this field if you want to inline the Envoy rate limits for this Route.
// Note that this does not configure the rate limit server. If you are running Gloo Enterprise, you need to
// specify the server configuration via the appropriate field in the Gloo `Settings` resource. If you are
// running a custom rate limit server you need to configure it yourself.
message RateLimitRouteExtension {

    // Whether or not to include rate limits as defined on the VirtualHost in addition to rate limits on the Route.
    bool include_vh_rate_limits = 1;

    // Define individual rate limits here. Each rate limit will be evaluated, if any rate limit
    // would be throttled, the entire request returns a 429 (gets throttled)
    repeated RateLimitActions rate_limits = 2;
}

// A setDescriptor is a list of key/value pairs that the rate limit server uses to select
// the correct rate limit to use when limiting with the set style. Descriptors are case-sensitive.
//
// Each configuration contains a simpleDescriptor list and a rateLimit.
// The format is:
//
// ```
// set_descriptors:
//  - simple_descriptors: (optional block)
//      - key: <rule key: required>
//        value: <rule value: optional>
//      - ... (repetition of above)
//    rate_limit:
//      requests_per_unit: <see below: required>
//      unit: <see below: required>
//    always_apply: <bool value: optional>
//  - ... (repetition of above)
// ```
//
// Each SetDescriptor defines a new Rate Limit "rule". When a request comes in, rate limit
// actions are applied to the request to generate descriptor tuples that are sent to the rate limit
// server. If any rule is triggered then the entire request returns HTTP 429 Too Many Requests.
//
// The `rate_limit` block sets up an actual rate limit rule.
message SetDescriptor {

    // Simple descriptor key/value pairs.
    repeated SimpleDescriptor simple_descriptors = 1;

    // Rate limit rule for the descriptor.
    RequestLimit rate_limit = 2;

    // Typically, rule priority is signalled by rule ordering, as the first rule match for
    // the descriptor tuple generated by the rate limit actions is used.
    //
    // In some cases this is too restrictive; A boolean override can be specified. Any rule with `alwaysApply` set to `true` will
    // always be considered for rate limiting, regardless of the rule's place in the ordered list of rules.
    // The first rule to match will still be considered. (This can be a rule that also has `alwaysApply` set to `true`.)
    //
    // If any of these rules trigger rate limiting then the entire request will return a 429.
    // Rules that are not considered for rate limiting are ignored in the
    // rate limit server, and their request count is not incremented in the rate limit server cache.
    //
    // Defaults to false.
    bool always_apply = 3;
}

// A simpleDescriptor is a list of key/value pairs that the rate limit server uses to select
// the correct rate limit to use when limiting with the set style. Descriptors are case-sensitive.
//
// The format is:
//
// ```
//  simple_descriptors:
//    - key: <rule key: required>
//      value: <rule value: optional>
//    - ... (repetition of above)
// ```
//
// Each simpleDescriptor in a simpleDescriptor list must have a key. It can also optionally have a value to enable
// a more specific match.
message SimpleDescriptor {

    // The key of the descriptor. This field is required.
    string key = 1;

    // Optional value for the descriptor. If omitted, the server will create a rate limit for
    // each value that is provided for this descriptor in rate limit requests.
    string value = 2;
}

// Each action and setAction in the lists maps part of the request (or its context) to a descriptor. The tuple or set of descriptors
// generated by the provided actions is sent to the rate limit server and matched against rate limit rules.
// Order matters on provided actions but not on setActions, e.g. the following actions:
// - actions:
//   - requestHeaders:
//      descriptorKey: account_id
//      headerName: x-account-id
//   - requestHeaders:
//      descriptorKey: plan
//      headerName: x-plan
// define an ordered descriptor tuple like so: ('account_id', '<x-account-id value>'), ('plan', '<x-plan value>')
//
// While the current form matches, the same tuple in reverse order would not match the following descriptor:
//
// descriptors:
// - key: account_id
//   descriptors:
//   - key: plan
//     value: BASIC
//     rateLimit:
//       requestsPerUnit: 1
//       unit: MINUTE
//  - key: plan
//    value: PLUS
//    rateLimit:
//      requestsPerUnit: 20
//      unit: MINUTE
//
// Similarly, the following setActions:
// - setActions:
//   - requestHeaders:
//      descriptorKey: account_id
//      headerName: x-account-id
//   - requestHeaders:
//      descriptorKey: plan
//      headerName: x-plan
// define an unordered descriptor set like so: {('account_id', '<x-account-id value>'), ('plan', '<x-plan value>')}
//
// This set would match the following setDescriptor:
//
// setDescriptors:
// - simpleDescriptors:
//   - key: plan
//     value: BASIC
//   - key: account_id
//  rateLimit:
//    requestsPerUnit: 20
//    unit: MINUTE
//
// It would also match the following setDescriptor which includes only a subset of the setActions enumerated:
//
// setDescriptors:
// - simpleDescriptors:
//   - key: account_id
//  rateLimit:
//    requestsPerUnit: 20
//    unit: MINUTE
//
// It would even match the following setDescriptor.
// Any setActions list would match this setDescriptor which has simpleDescriptors omitted entirely:
//
// setDescriptors:
// - rateLimit:
//    requestsPerUnit: 20
//    unit: MINUTE
message RateLimitActions {
    // TODO: come up with descriptive names and comments for these fields
    repeated Action actions = 1;
    repeated Action set_actions = 2;
}

// A `RateLimit` specifies the actual rate limit that will be used when there is a match.
message RequestLimit {

    enum Unit {
        UNKNOWN = 0;
        SECOND = 1;
        MINUTE = 2;
        HOUR = 3;
        DAY = 4;
    }

    Unit unit = 1;

    uint32 requests_per_unit = 2;
}

// Copied directly from envoy
// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-msg-config-route-v3-ratelimit-action
message Action {

    oneof action_specifier {

        // Rate limit on source cluster.
        SourceCluster source_cluster = 1;

        // Rate limit on destination cluster.
        DestinationCluster destination_cluster = 2;

        // Rate limit on request headers.
        RequestHeaders request_headers = 3;

        // Rate limit on remote address.
        RemoteAddress remote_address = 4;

        // Rate limit on a generic key.
        GenericKey generic_key = 5;

        // Rate limit on the existence of request headers.
        HeaderValueMatch header_value_match = 6;

        // Rate limit on metadata.
        MetaData metadata = 8;
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("source_cluster", "<local service cluster>")
    // ```
    //
    // <local service cluster> is derived from the :option:`--service-cluster` option.
    message SourceCluster {
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("destination_cluster", "<routed target cluster>")
    // ```
    //
    // Once a request matches against a route table rule, a routed cluster is determined by one of
    // the following `route table configuration (envoy_api_msg_RouteConfiguration)`
    // settings:
    //
    // * `cluster (envoy_api_field_route.RouteAction.cluster)` indicates the upstream cluster
    //   to route to.
    // * `weighted_clusters (envoy_api_field_route.RouteAction.weighted_clusters)`
    //   chooses a cluster randomly from a set of clusters with attributed weight.
    // * `cluster_header (envoy_api_field_route.RouteAction.cluster_header)` indicates which
    //   header in the request contains the target cluster.
    message DestinationCluster {
    }

    // The following descriptor entry is appended when a header contains a key that matches the
    // *header_name*:
    //
    // ```
    //   ("<descriptor_key>", "<header_value_queried_from_header>")
    // ```
    message RequestHeaders {
        // The header name to be queried from the request headers. The header’s
        // value is used to populate the value of the descriptor entry for the
        // descriptor_key.
        string header_name = 1; // [(validate.rules).string.min_bytes = 1];

        // The key to use in the descriptor entry.
        string descriptor_key = 2; // [(validate.rules).string.min_bytes = 1];
    }

    // The following descriptor entry is appended to the descriptor and is populated using the
    // trusted address from `x-forwarded-for (config_http_conn_man_headers_x-forwarded-for)`:
    //
    // ```
    //   ("remote_address", "<trusted address from x-forwarded-for>")
    // ```
    message RemoteAddress {
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("generic_key", "<descriptor_value>")
    // ```
    message GenericKey {
        // The value to use in the descriptor entry.
        string descriptor_value = 1; // [(validate.rules).string.min_bytes = 1];
    }

    // The following descriptor entry is appended to the descriptor:
    //
    // ```
    //   ("header_match", "<descriptor_value>")
    // ```
    message HeaderValueMatch {

        message HeaderMatcher {

            // Specifies the int64 start and end of the range using half-open interval semantics [start,
            // end).
            message Int64Range {
                // start of the range (inclusive)
                int64 start = 1;

                // end of the range (exclusive)
                int64 end = 2;
            }

            // Specifies the name of the header in the request.
            string name = 1; // [(validate.rules).string.min_bytes = 1];

            reserved 2; // value deprecated by `exact_match
            // (envoy_api_field_route.HeaderMatcher.exact_match)`

            reserved 3; // regex deprecated by `regex_match
            // (envoy_api_field_route.HeaderMatcher.regex_match)`

            // Specifies how the header match will be performed to route the request.
            oneof header_match_specifier {

                // If specified, header match will be performed based on the value of the header.
                string exact_match = 4;

                // If specified, this regex string is a regular expression rule which implies the entire request
                // header value must match the regex. The rule will not match if only a subsequence of the
                // request header value matches the regex. The regex grammar used in the value field is defined
                // `(here)[https://en.cppreference.com/w/cpp/regex/ecmascript]`.
                //
                // Examples:
                //
                // * The regex *\d{3}* matches the value *123*
                // * The regex *\d{3}* does not match the value *1234*
                // * The regex *\d{3}* does not match the value *123.456*
                string regex_match = 5; // [(validate.rules).string.max_bytes = 1024];

                // If specified, header match will be performed based on range.
                // The rule will match if the request header value is within this range.
                // The entire request header value must represent an integer in base 10 notation: consisting of
                // an optional plus or minus sign followed by a sequence of digits. The rule will not match if
                // the header value does not represent an integer. Match will fail for empty values, floating
                // point numbers or if only a subsequence of the header value is an integer.
                //
                // Examples:
                //
                // * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
                //   "-1somestring"
                Int64Range range_match = 6;

                // If specified, header match will be performed based on whether the header is in the
                // request.
                bool present_match = 7;

                // If specified, header match will be performed based on the prefix of the header value.
                // Note: empty prefix is not allowed, please use present_match instead.
                //
                // Examples:
                //
                // * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
                string prefix_match = 9; // [(validate.rules).string.min_bytes = 1];

                // If specified, header match will be performed based on the suffix of the header value.
                // Note: empty suffix is not allowed, please use present_match instead.
                //
                // Examples:
                //
                // * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
                string suffix_match = 10; // [(validate.rules).string.min_bytes = 1];
            }

            // If specified, the match result will be inverted before checking. Defaults to false.
            //
            // Examples:
            //
            // * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
            // * The range [-10,0) will match the value -1, so it will not match when inverted.
            bool invert_match = 8;
        }

        // The value to use in the descriptor entry.
        string descriptor_value = 1; // [(validate.rules).string.min_bytes = 1];

        // If set to true, the action will append a descriptor entry when the
        // request matches the headers. If set to false, the action will append a
        // descriptor entry when the request does not match the headers. The
        // default value is true.
        google.protobuf.BoolValue expect_match = 2;

        // Specifies a set of headers that the rate limit action should match
        // on. The action will check the request’s headers against all the
        // specified headers in the config. A match will happen if all the
        // headers in the config are present in the request with the same values
        // (or based on presence if the value field is not in the config).
        repeated HeaderMatcher headers = 3; // [(validate.rules).repeated .min_items = 1];
    }

}

// The following descriptor entry is appended when the metadata contains a key value:
//   ("<descriptor_key>", "<value_queried_from_metadata>")
message MetaData {
    enum Source {
        // Query [dynamic metadata](https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata#well-known-dynamic-metadata).
        DYNAMIC = 0;

        // Query [route entry metadata](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-route-metadata).
        ROUTE_ENTRY = 1;
    }

    // MetadataKey provides a general interface using `key` and `path` to retrieve value from
    // [`Metadata`](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-metadata).
    //
    // For example, for the following Metadata:
    //
    // ```yaml
    // filter_metadata:
    //   envoy.xxx:
    //     prop:
    //       foo: bar
    //       xyz:
    //         hello: envoy
    // ```
    //
    // The following MetadataKey will retrieve a string value "bar" from the Metadata.
    //
    // ```yaml
    // key: envoy.xxx
    // path:
    // - key: prop
    // - key: foo
    // ```
    //
    message MetadataKey {

        // Specifies the segment in a path to retrieve value from Metadata.
        // Currently it is only supported to specify the key, i.e. field name, as one segment of a path.
        message PathSegment {
            oneof segment {
                // option (validate.required) = true;

                // Required. If specified, use the key to retrieve the value in a Struct.
                string key = 1; // [(validate.rules).string = {min_len: 1}];
            }
        }

        // Required. The key name of Metadata to retrieve the Struct from the metadata.
        // Typically, it represents a builtin subsystem or custom extension.
        string key = 1; // [(validate.rules).string = {min_len: 1}];

        // Must have at least one element. The path to retrieve the Value from the Struct. It can be a prefix or a full path,
        // e.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example,
        // which depends on the particular scenario.
        //
        // Note: Due to that only the key type segment is supported, the path can not specify a list
        // unless the list is the last segment.
        repeated PathSegment path = 2; // [(validate.rules).repeated = {min_items: 1}];
    }

    // Required. The key to use in the descriptor entry.
    string descriptor_key = 1; // [(validate.rules).string = {min_len: 1}];

    // Required. Metadata struct that defines the key and path to retrieve the string value. A match will
    // only happen if the value in the metadata is of type string.
    MetadataKey metadata_key = 2; // [(validate.rules).message = {required: true}];

    // An optional value to use if *metadata_key* is empty. If not set and
    // no value is present under the metadata_key then no descriptor is generated.
    string default_value = 3;

    // Source of metadata
    Source source = 4; // [(validate.rules).enum = {defined_only: true}];
}